<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Faster Subtree Isomorphism</title>
      <link href="/2019/11/23/FasterSubtreeIsomorphism/"/>
      <url>/2019/11/23/FasterSubtreeIsomorphism/</url>
      
        <content type="html"><![CDATA[<!--图片可用这种结构：<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="这里输入图片地址">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">这里输入题注</div></center>--><p>这是数据结构课程设计的论文一的<del>分析与理解</del> <code>翻译</code>，原文可以在<a href="https://www.cs.bgu.ac.il/~dekelts/publications/subtree.pdf" title="论文源地址" target="_blank" rel="noopener">这个链接</a>下载。原作者是 Ron Shamir和 Dekel Tsur 。<br><a id="more"></a></p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本片论文的原标题是这个：</p><blockquote><p>Faster Subtree Isomorphism</p></blockquote><p>译成中文则是更快的子树同构，从概要里可以得出，这是在树 $H$ 和树 $G$ 两棵树中进行操作，并且在 $G$ 树中找到一棵与 $H$ 树同构的子树（或是没有）的算法。他们给出了一个时间复杂度为$O(\frac{k^{1.5}}{\log k}n)$的算法，其中 $k$ 和 $n$ 分别是 $H$ 和 $G$ 树的的顶点数。这提高了之前 Chung 和 Matula 的算法（时间复杂度为$O(k^{1.5}n)$）。当然，他们也给出了一个随机化的O(k^{1.376}n)时间复杂度的选择算法。<br>以下是英文原文</p><blockquote><p>We study the subtree ismorphism problem: Given trees $H$ and $G$, find a subtree of $G$ which is isomorphic to $H$ or decide that there is no such subtree. We give an $O((k^{1.5}/{\log k})n)$-time alogorithm for this problem, where $k$ and $n$ are the number of vertices in H and G, respectively. This improves over the $O(k^{1.5}n)$ algorithms of Chung and Matula. We also give a randomized (Las Vegas) $O(k^{1.376}n)$-time algorithm for the decision problem.</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我们知道，图论中有一个基础问题则是图的同构问题，给定两个图 $G$ 和 $H$，找到 $G$ 的一个子图，使得该子图与 $H$ 同构。这是一个 NPH 问题。  </p><blockquote><p>NP 问题就是在多项式时间内可以被验证其正确性的问题。如果所有NP问题都可以多项式时间归约到某个问题，则称该问题为NP困难（即 NPH ）。</p></blockquote><p>如果我们限制在 $G$ 图中，这个子图同构问题或许会变得更加简单。对于以下问题给出了多项式的时间算法：树、二连通的外部平面图以及串并联图。</p><blockquote><p>外部平面图是一个平面图满足存在一个画在平面上的方法使得外围面的边界包含所有顶点，该画法被称为该图一个外围平面嵌入。外围平面图一定是平面图但反过来不一定成立，例如完全图 $K_4$ 是平面图但并非外围平面图。库拉托夫斯基定理友在外围平面图上的版本：一个图是外围平面图当且仅当它并不包含一个是 $K_4$ 或 $K_{2, 3}$ 的分割的子图。事实上，该版本是下述事实的直接推论：图 $G$ 是外围平面图当且仅当在 $G$ 外面加一个顶点，连边到 $G$ 的所有顶点，所得到的图是平面图。</p></blockquote><p>所有的这些图的节点的儿子数都至多为2。当图 $G$ 满足以上条件时，任意给出的图 $G$ 都使得这个图同构问题是一个NPH问题。（事实上，即使是图 $G$ 每个非树叶节点都有2个儿子并且图 $H$ 为树，他们都只有至多一个节点的度超过3 ，它仍然是一个NPH问题。），甚至当图 $G$ 的路宽为2时亦是如此。不过，对于那些树宽至多为 $p$ 且 $p \geq 2$ 的图来说，这个问题就是多项式的了。</p><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2019/11/23/FasterSubtreeIsomorphism/Figure1.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1 一个子树同构问题的实例。树 $G$ 拥有一棵与图 $H$ 同构的子树</div><br></center><p>如果我们加入限制条件：图 $G$ 是<em>p连通</em>的，或者图 $H$ 拥有有界的度。一个更快的算法就可以给出。 </p><blockquote><p>p连通<br>对于 $V(G)$ 的每个分割(分成 $X$ 和 $Y$)，都存在一个$P_4$，其中$P_4$包含同时存在于 $X$ 和 $Y$ 内的节点。</p></blockquote><p>这个子树同构问题在外部平面图也可以给出多项式时间的算法，或者更广泛的说，在没有 ${K_{3,σ}}$ 图子式的情况下，可以给出。</p><blockquote><p>图子式：在图论中，如果无向图 $H$ 可以通过图$G$ 删除边和顶点或收缩边得到，则称 $H$ 为 $G$ 的子式（minor）或次图。</p></blockquote><p>在这篇文章中我们讨论<em>子树同构问题</em>，也即是当图 $G$ 和图 $H$ 均为树时的情况。图1给出了一个该问题的实例子图同构问题和子树同构问题都在模式识别、计算生物学、化学中有所应用。</p><blockquote><p>模式识别（Pattern recognition），就是通过计算机用数学技术方法来研究模式的自动处理和判读。 我们把环境与客体统称为“模式”。 随着计算机技术的发展，人类有可能研究复杂的信息处理过程。 信息处理过程的一个重要形式是生命体对环境及客体的识别。<br>计算生物学（Computational Biology）是生物学的一个分支。 根据美国国家卫生研究所（NIH）的定义，它是指开发和应用数据分析及理论的方法、数学建模和计算机仿真技术，用于生物学、行为学和社会群体系统的研究的一门学科。<br>化学（Chemistry）是自然科学的一种，在分子、原子层次上研究物质的组成、性质、结构与变化规律；创造新物质的科学。</p></blockquote><p>在这个工作中，$n$ 和 $k$ 分别表示了图 $G$ 和 图 $H$ 中的节点数量。当 $k = n$ 时我们得到了线性算法复杂度的<em>树同构问题</em>（基于 Hopcroft 和 Tarjan 的研究成果）多项式时间的子树同构算法首次被 Matula 和 Edmonds 提出。更快的算法又被 Matula 和 Chung 给出。Chung 的算法的时间复杂度为 $O(k^{1.5}n)$。此外，子树同构问题也在 RNC 之中，顾名思义，它可以被一个随机并行算法(Randomized parallel algorithm)在 $\log^{O(1)n}$时间内解决，并且当这个问题限制在对数空间的树中时，它就因此进入 NC 了（？笔者水平问题，意义不明）。与此形成鲜明对比的是，当图 $G$ 是树而 $H$ 是森林时（子森林同构），这个子图同构问题就成了 NPH 了。</p><blockquote><p>森林比树少一个条件，指没有回路的图。也就是说，森林可能是不连通的，边数可能比树还少，就是说小于顶点数。<br>森林也可以看成是好多棵互不相连的非空的树，只有一棵树也可以算是森林。不过森林不一定是一棵树。<br>森林也可以是有根的，这时候森林中的每一棵树都有一个根。<br>一棵树去掉若干条边也会成为森林，这时候可以看成一棵树分成了好多棵树。森林中的两棵树之间加一条边，也可以把这两棵树合在一起，最终合成一棵树。<br>很多地方用森林，都是用来表示很多棵树，包括作为逻辑结构、数据结构的时候等。有一种重要的数据结构并查集就是一个有根的森林，可以很快的判断两个元素是不是属于同一个互相独立的集合，以及合并两个集合等。<br>——引用自维基百科</p></blockquote><p>在有根树上的子树同构问题如下：给定两个有根树 $G$ 和 $H$，找到 $G$ 的一个子图 $G’$（$G’$ 的根也是 $G$ 的根），在 $H$ 和 $G’$ 之间存在一个同构映射，将 $H$ 的根映射到 $G’$ 的根。这个问题可以在 $O(min(k^{1.5},\sqrt{k}n\log \log n/ \log n)·n)$ 的时间内解决。一个类似的问题是树的模式匹配问题：输入两个有根树 $G$，$H$ 和一串子树值的节点。目标是找到一个从图 $H$ 到图 $G$ 的1-1映射，使得每一个 $H$ 中的节点都能映射到 $G$ 中。在 $v$ 中的第 $i$ 个节点就是 $f(v)$ 中的第 $i$ 个孩子。这个树模式匹配问题可以在 $n \log^{O(1)}$ 的时间内解决。<br>几个子树同构问题的推广已被研究。在<em>最大相似子树问题</em>中，输入树 ${G_1,… ,G_n}$ ，目标是找到一棵拥有最多节点的树 $H$ ，对于每棵树 $G_i$ 都包含又一个子图与 $H$ 同构。这个问题对于两棵树是多项式的（并且 RNC ），当树的数量达到3棵及以上时，它就成了 NPH 了。 近似的该问题算法已经给出。另一个推广则是<em>最大子森林问题</em> ：查找具有最大边数的给定树的子树，该子树不包含与给定树集中的任何树同构的子图。<br><s>我们</s><code>作者</code>的主要成果是一个 $O((k^{1.5}/logk)n)$ 时间的算法。像大多数该问题的研究一样，是基于是基于二部图的子树同构和最大匹配之间的密切关系。将子树同构问题递归地转化为一组较小的子树同构问题，利用最大匹配算法求解。改进的复杂度是通过一个组合引理来实现的，该引理限定了所涉及的不同子树的可能数目，并通过使用团划分的概念以及 Feder 和 Motwani 的应用来确定二部图中的最大匹配。我们证明了对于由子树同构问题产生的匹配问题，我们可以用一种简单的方法找到一个团分区。我们在这里使用的思想，也提出了一个关于最大子森林问题的改进算法。<br>我们也给出了一个随机化的算法给这个选择问题，期望的运行时间是 $O(k^{ω-1}n)$，式中ω是矩阵乘法的指数。使用已知的最优界给ω，则上界为 $O(k^{1.376}n)$。该算法直接遵循由 Cheriyan 给出的寻找最大匹配基数的随机算法。这个章节的结果发表在另外的论文上。<br>文章剩下的部分组成如下：第二节描述了一个 $O(k^{1.5}n)$ 的算法。在第3节我们证明了一些简单的在后续章节中需要用的引理。在第4节中，我们证明了组合引理，并将其与团划分结合使用，以提高第二节算法的运行时间。最后第5节描述了这个随机化算法。<br>我们用一些定义来结束本节内容。对于大多数的定义和基本的图论术语可以查看相关资料。一棵<em>有根树</em>是一个三联体 $G=(V,E,r)$，其中 $(V,E)$ 是一个无根树，$r$ 是 $V$ 中的一些称作“根”的节点。我们有时候也写作 $G^r$ 来表示 $r$ 是有根树 $G$ 的根。同时，对于一棵无根树，我们用 $G^r$ 来表示一颗有根树，这颗有根树是选择了它的一个节点 r 作为其根。我们用 $G^r_v$ 来表示有根树 $G^r$ 的一棵子树，这颗字数的节点均为 $v$ 的后代，它的根是 $v$ 。<br>当有一个同构关系在两颗有根树 $G^r$ 和 $H^s$ 之间，并且将 $r$ 映射到 $s$ 时，我们称是这两棵树是<em>同构的</em>。同样的，当有一颗 $G^r$ 的有根子树 $J^r$ 与 $H^s$ 同构时，我们写作 $H^s\subseteq_RG^r$。（注意到子树 $J^r$ 必须与 $G^r$ 有相同的根）<br>我们定义一个图 $G$ 中节点 $v$ 的<em>开社区(open neighborhood)</em>为 $N(v)={u:uv∈E}$，定义<em>闭社区(closed neighborhood)</em> 为 $N[v]=N(v)∪ \lbrace {v} \rbrace$。我们使用 $d_G(v)$来表示节点 $v$ 在图 $G$ 中的度（或者 $d(v)$ 当图 $G$ 指明的情况下）。  </p><h2 id="一个-O-k-1-5-的算法"><a href="#一个-O-k-1-5-的算法" class="headerlink" title="一个 $O(k^{1.5})$ 的算法"></a>一个 $O(k^{1.5})$ 的算法</h2><p>在这一节我们描述了一个 $O(k^{1.5})$ 算法，使之为在章节4和5中所改进的算法作基础。它建立在 Chung 的算法基础，与之拥有相同的渐进时间复杂度，但是它相比于 Chung 的算法更加简单，因为 $G$ 树只被遍历了一次（Chung 的算法遍历了两次）。我们简短地描述一下算法的完备性。我们注意到在第4和5节的改进也同样可以运用至 Chung 的原始算法。简单起见，我们描述一个算法来讨论这个问题，它也能很简单地扩展被用于搜索问题。<br>我们设 $G=(V,E)$ 和 $H=(V_H,E_H)$ 是输入的树（不失一般性，$|V_H|&gt;1$）。选择 $G$ 的一个节点 $r$ 作为其根。我们希望知道对于每一个 $v∈V$ 和 $u∈V_H$ 是否有 $H^u \subseteq_RG^r_v$ 。为了计算这个的效率，我们也需要知道对于每个 $u$ 的邻居 $w$ 是否有 $H^w_u\subseteq_RG^r_v$（注意到 $H^w_u$ 是图 $H^u$ 删去 $H^u_w$ 得到的）。这个信息是重要的，因为 $H^u\subseteq_RG^r_v$ 当且仅当 $u$ 的每一个儿子 $u’$ 都有 $v$ 的唯一的儿子 $v’$ 使得 ${H^u_{u &#39;} \subseteq_RG^r_{v &#39;} }$ 。更加广泛地说，我们得到如下引理：</p><blockquote><p><strong>引理2.1</strong>：对于每一个 $G^r$ 中的节点 $v$ ，每一个 $H$ 中的节点 $u$ 和一个 $w∈N[u]$ 的节点 $a$，如果对 $H^w_u$ 中每一个 $u$ 的孩子 $u’$ 都有在 $v$ 唯一的孩子 $v’$，即 $H^u_{u’} \subseteq_RG^r_{v’}$ ，那么我们有 $H^u_{u’} \subseteq _RG^r_v$。</p></blockquote><p>我们将这个信息存进集合 $S(v,u)$ 中，定义如下：对任意 $v \in V$ 和  $u \in V_H$ 有：$$ S(v,u)=\lbrace w \in N[u]:H^w_u \subseteq_RG^r_v \rbrace$$<br>我们看图2作为这个定义的例子。注意到（1） $u \in S(v,u)$ 当且仅当 $H^u=H^u_u \subseteq_RG^r_v$，（2） $u \in S(v,u) $ 意味着 $S(v,u)=N[u]$，（3）$d(v)&lt;d(u)-1$ 意味着 $S(v,u)=\phi$。<br>这个算法计算了所有的 $u$ 和 $v$ 的 $S(v,u)$ 。我们将展示如何通过从根到叶地遍历 $G^r$ 中的所有节点 $v$ 并计算所有的 $u \in V_H$ $S(v,u)$ ，以此归纳计算 $S(v,u)$ （这个算法也在第三章使用伪代码进行了描述）。这个归纳法的基础是当 $v$ 是 $G^r$ 的叶子节点。 然后 $S(v,u)$ 就可以以下述方法计算所有的 $u$ ：如果 $u$ 是 $H$ 的叶子，那么 $S(v,u)$ 就是由一个 $H$ 中只有单邻居的节点 $u$ 所组成的了。否则，如果 $u$ 是一个内部顶点， $S(v,u)$ 为空。  </p><blockquote><p>叶子节点：没有子节点的节点</p></blockquote><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2019/11/23/FasterSubtreeIsomorphism/Figure2.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图2 一个子树同构问题的实例。在这里我们有 $H^u,H^{u_2}_u \not\subseteq_R G^r_v和H^{u_1}_u,H^{u_3}_u \subseteq_RG^r_v$，所以有 $S(v,u) = \lbrace u_1,u_3 \rbrace$ 图 $B(v,u)$ 是一个我们用于计算 $S(v,u)$ 所构建的二部图。有一条边 $u_iv_j$在这个图中当且仅当 $u \in S(v_j,u_i)$。$H^u \not\subseteq_RG^r_v$ 正如 $B(v,u)$不包含大小为3的匹配。$H^{u_1}\subseteq_RG^r_v$ 正如$B_{u_1}(v,u)=B_{v_1}(v,u)=B(v,u)-u_1$ 包含了一个大小为2的匹配</div><br></center><p>对于归纳步骤，考虑一个内部点 $v$（根据（3）我们可以假设 $d(v) \geq d(u)-1$）。我们首先需要计算对于所有的 $u \in V_H$ 所有 $v$ 的儿子 $v’$ 的$S(v’,u)$。然后，为了判断是否对于 $w \in N[u]$ 有 $w \in S(v,u)$，我们构造一个二部图 $B_w(v,u)$，它由两部分构成：$X^{v,u}_w$ 和 $Y^{v,u}$，其中 $X^{v,u}_w$ 是 $H^w_u$ 中节点 $u$ 的孩子集合，$Y^{v,u}是 $v$ 的孩子集合$，${u’v’}$ 是图 $B_w(v,u)$的一条边当且仅当 $H^u_{u’} \subseteq_RG^r_{v’}$（也即是说当且仅当 $u \in S(v’,u’)$）。根据引理2.1，$w$ 在 $S(v,u)$ 中当且仅当 $B_w(v,u)$ 有一个大小为 $|{X^{v,u}_w}|$ 的匹配。因此，为了计算 $S(v,u)$ 我们需要在 $d(u)+1$ 的二部图中找到最大的匹配。不过，所有的这些图都彼此相似：每一个图 $B_w(v,u)(w \not= u)$ 都是通过从图 $B_u(v,u)$ 中删去节点 $w$ 来得到。在第3节（推论3.2）中我们将证明只在图 $B_u(v,u)$ 中寻找最大匹配是足够的，然后我们可以有效地计算出所有满足 $w\not=u$ 在 $B_w(v,u)$ 中最大匹配的大小。在接下来的部分，我们将使用 $B(v,u)$ 而非 $B_u(v,u)$。看图2来找寻一个关于 $S(v,u)$ 和 $B(v,u)$ 关系的例子。<br>子树同构算法将在图3以伪代码形式进行展示。</p><blockquote><p> <strong>定理2.2</strong>：子树同构算法以 $O(k^{1.5}n)$ 的时间复杂度和 $O(kn)$ 的空间复杂度解决子树同构问题</p><blockquote><p> <strong>证明</strong>：算法的正确性来源于引理2.1。让我们考虑下空间复杂度。设 $V=\lbrace x_1,\dots,x_n \rbrace$， $V_H=\lbrace y_1,\dots,y_n\rbrace$。由于每一个集合 $S(v,u)$ 都是 $N[u]$ 的子集，我们可以使用一个大小为 $|{N[u]}|$ 二元向量 $A(v,u)$ 来维护 $S(v,u)$。同时，我们也可以维护一个 $k\times k$ 的矩阵 $I$，其中 $I(u,w)$ 是在向量 $A(v,u)$ $w \in N[u]$ 的索引号。换言之，$w \in S(v,u)$ 当且仅当比特编号 $I(u,w)$ 在 $A(v,u)$ 中是一个集合。因此空间复杂度是 $O(k^2+\sum^k_{j=1}{d(y_i)n})=O(kn)$ 并且每一次对 $S(v,u)$ 的访问花费的是常数时间。</p></blockquote></blockquote><center><br>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2019/11/23/FasterSubtreeIsomorphism/Figure3.png"><br>    <br><br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图3 子树同构算法$(G,H)$</div><br></center><blockquote><ol><li>选择 $G$ 一个节点 $r$ 作为 $G$ 的根节点</li><li>对于所有的 $u \in H$ 和 $v \in G$ 将 $\phi$ 添加进 $S(v,u)$</li><li>对于 $G^r$ 中所有的叶子 $v$ 执行：</li><li>对于 $H$ 所有的叶子 $u$ 将 $N[u]$ 添加进 $S(v,u)$ </li><li>对处于先序遍历的 $G^r$ 所有的内部节点 $v$ 执行：</li><li>将 $u_1,\dots,u_s$ 设置为 $v$ 的孩子</li><li>对于 $H$ 所有度不超过 $t+1$ 的节点 $u=u_0$执行：</li><li>使 $u_1,\dots,u_s$成为 $v$ 的孩子</li><li>构造二部图 $B(v,u)=(X,Y,E_{vu})$，其中 $X=\lbrace u1,\dots,u_s\rbrace$，$Y=\lbrace v_1,\dots,v_t\rbrace$，$E_{vu}=\lbrace u_iv_j:u\in S(v_j,u_i)\rbrace$ 使用如下表示：$X_0=X$ $X_i=X-\lbrace u_i \rbrace$</li><li>对于所有的 $0 \leq i \leq s$ 计算大小 $m_i$，找到 $X_i$ 和 $Y$ 之间的最大匹配。</li><li>将 $\lbrace u_i:m_i=|{X_i}|,0 \leq i \leq s\rbrace$ 添加进 $S(v,u)$</li><li>如果 $u \in S(v,u)$ 那么答案是<strong>是</strong>，停止。</li><li>循环结束标识对应第7行</li><li>循环结束标识对应第5行</li><li>答案是<strong>否</strong></li></ol></blockquote><p>至于算法的空间复杂度，关键在于第10步。它计算了一些图中的最大匹配的规模。因为这些图都是高度相关的，我们能够在第3节中得到：计算它们的最大匹配的大小可以在计算单个最大匹配的同一时间内完成。因此，我们使用推论3.2执行算法的第10步，因此其时间复杂度的主要部分是第10步确定图 $B(x_i,y_i)$ 对于所有的 $i$，$j$的讨论。使用 Hopcroft 和 Karp 的算法找出一个 $B(x_i,y_i)$ 的最大匹配花费的时间是 $O(d(y_i)^{1.5}d(x_i))$（或者 Dinic 的等效算法）因此花费在处理节点 $x_i$ 上的时间最多是 $O(\sum^k_{j=1}{d(y_j)^{1.5}d(x_i)}=O((2k)^{1.5}d(x_i))$。因此，总时间复杂度为 $O(k^{1.5}n)$<br>我们注意到上述算法可以被用于解决<em>子树同胚问题</em>而不需要改变渐进的复杂度。对算法的相同修改应用在后面的章节。</p><blockquote><p>在拓扑学中，同胚(homeomorphism、topological isomorphism、bi continuous function)是两个拓扑空间之间的双连续函数。同胚是拓扑空间范畴中的同构；也就是说，它们是保持给定空间的所有拓扑性质的映射。如果两个空间之间存在同胚，那么这两个空间就称为同胚的，从拓扑学的观点来看，两个空间是相同的。<br>两个拓扑空间 $\lbrace X,T_X \rbrace$ 和$\lbrace Y,T_Y \rbrace$之间的函数 $f:x \to y$ 称为同胚，如果它具有下列性质：<br> $f$ 是双射（单射和满射）；<br> $f$ 是连续的；<br>反函数 $f^{-1}$ 也是连续的（ $f$ 是开映射）。<br>满足以上三个性质的函数有时称为双连续。自同胚就是从一个拓扑空间到它本身的同胚。同胚形成了所有拓扑空间的类上的等价关系。所得到的等价类称为同胚类。<br>——引自维基百科</p></blockquote><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>在这一节，我们给出了几个关于匹配的引理，这些引理对于得到更有效的子树同构问题是必须要的。对于接下来的引理，我们设 $B=(X,Y,E)$ 是一个二部图，其中 $X=\lbrace x_1,\dots,x_s\rbrace$，$Y=\lbrace y_1,\dots,y_t\rbrace$ 并且 $s \leq t+1$。对于 $1 \leq i \leq s$，用 $X_0=X$ 和 $X_i=X-\lbrace x_i \rbrace$ 进行表示。对于 $0 \leq i \leq s$，令 $m_i$ 表示在 $X_i$ 和 $Y$ 之间最大的匹配。显然对于任意的 $i \geq 1$，有 $m_i=m_0$ 或是 $m_i=m_0-1$。<br>一个匹配中重要的概念就是临界点。对于图 $G$ 中的一个节点 $x$，当在 $G-x$ 的最大匹配严格小于在 $G$ 中的最大匹配时，我们说 x 是<em>临界</em>的（也即是说 $x_i$ 是临界的当且仅当 $m_i=m_0-1$）。设 $M$ 是 $B$ 的最大匹配。我们定义一个有向图 $B_M$，使 $B_M=(X\cup Y,E_M)$ ，其中有$$E_M=\lbrace (x,y):xy \in E-M,x \in X,y \in Y\rbrace \cup \lbrace (y,x):xy \in M,x \in X, y\in Y \rbrace$$<br>我们用 $X_M$ 表示所有 $X$ 中的不与 $M$ 匹配的节点。</p><blockquote><p><strong>引理3.1</strong>：对于 $B$ 中每一个最大匹配 $M$，和任意 $x_i \in X$，$x_i$ 临界（即是 m_i=m_0-1）当且仅当 $x_i$ 在 $M$ 中匹配并且在 $B_M$ 不存在一条路径能够从 $X_M$ 到 $x_i$。</p><blockquote><p><strong>证明</strong>：（充分性）我们用反证法进行证明。如果 $x_i$ 在 $M$ 中不匹配，那么 $M$ 就是在 $X_i$ 和 $Y$ 之间，因此有 $m_i=m_0$，矛盾（$m_i=m_0-1$）。当然，如果 $B_M$ 有一条从 $X_M$ 到 $x_i$ 的路径 $P$，那么 $M\Delta P(=M \cup P-M\cap P)$ 就是一个 $x_i$ 不匹配的最大匹配，我们再一次得到了 $m_i=m_0$ 的矛盾。<br>（相反地），从矛盾开始假设，设 $m_i=m_0$。设 $y$ 是在 $M$ 中匹配 $X-i$ 的节点。又 $|{M-\lbrace x_iy \rbrace}|=m_0-1 &lt; m_i$，$M-\lbrace x_iy \rbrace$ 不是一个在 $X_i$ 和 $Y$ 之间的最大匹配，并且在 Berge 的理论中，存在一条<em>增广路径</em> $P$ 到达 $X_M$ 中的一个节点 $x_j$，另一个节点是 $y$ （因为如果另一个是 $Y$ 中节点且在 $M$ 中不匹配的话，$P$ 就是 $M$ 的一条增广路径）。但是这意味着一条在有向图 $B_M$ 中的从 $x_j$ 到 $x_i$ 的路径，矛盾。<br>增广路径：若P是图G中一条连通两个未匹配顶点的路径，并且属于M的边和不属于M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。</p></blockquote></blockquote><blockquote><p><strong>推论3.2</strong>：给定一个 $B$ 的最大匹配 $M$，我们可以在 $O(st)$ 的时间内计算出 $m_i$ 的值，其中 $0 \leq i \leq s$。</p><blockquote><p><strong>证明</strong>：构造图 $B_M$ 并且找到所有从 $X_M$ 可达到的节点，这可以在 $O(st)$ 的时间内使用<em>深度优先搜索</em>完成。然后应用引理3.1。对于任意一个 $x_i$，如果 $x_i$ 在 $M$ 中匹配且不可从 $X_M$ 到达，我们设 $m_i=|M|-1$，否则 $m_i=|M|$。</p><blockquote><p>深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p></blockquote></blockquote></blockquote><blockquote><p><strong>引理3.3</strong>：在 $B$ 中找到一个最大匹配的问题可以被缩减到 $O(st)$ 的时间变成找到 $B$ 的一个子图的最大匹配，其中该子图拥有最多 $s^2$ 条边和节点，节点的最大度为 $s$。</p><blockquote><p><strong>证明</strong>：设 $X’$ 是所有的 $X$ 中度小于 $s$ 的节点集合。设 $B’$ 是由 $X’$ 及其邻居从 $B$ 中导出的子图。构建 $X’$ 和 $B’$ 花费 $O(|X|+|Y|+|E|)=O(st)$ 的时间。我们说给定 $B’$ 的最大匹配 $M’$，我们可以构建一个 $B$ 的最大匹配 $M$：首先将 $M’$ 中的所有边添加至 $M$。对于 $X-X’$ 中的每一个节点，找到 $Y$ 中的一个不匹配的邻居 $y$ 然后将 $xy$ 添加到 $M$（这样一个节点 $y$ 一定存在，因为这样的 $x$ 拥有至少 $s$ 个邻居并且至多 $s-1$ 个邻居是匹配的）。找到 $x$ 的一个不匹配邻居花费 $O(s)$ 的时间，因此构建 $M$ 花费 $O(s^2)$ 的时间。</p></blockquote></blockquote><h2 id="一个-O-frac-k-1-5-log-k-n-的算法"><a href="#一个-O-frac-k-1-5-log-k-n-的算法" class="headerlink" title="一个 $O(\frac{k^{1.5}}{\log k}n)$ 的算法"></a>一个 $O(\frac{k^{1.5}}{\log k}n)$ 的算法</h2><p>我们现在来对章节2中的算法进行 $\log k$ 因子的改进。我们使用之前的算法，但是如果我们通过利用二部图的团划分思想及其在最大匹配中的应用，将会在解决最大匹配问题时更加高效。Feder 和 Motwani 的算法最初是针对具有相同大小部分的二部图提出的，可以推广到一般的二部图。这使得我们可以给出时间复杂度为 $O((k^{1.5}/\log k)n)$ 的子树同构算法。我们不去描述对 Feder 和 Motwani 算法的修改，我们这里给出一个更简单的方法来得到一个 $O((k^{1.5}/\log k)n)$ 时间的子树同构算法。相比之下，[16]（参考文献，这里不列出）利用了图的稠密性，而我们利用子树同构算法中必须解决的匹配问题的特殊结构，实现了时间复杂度的降低。<br>修改后的算法，叫做<strong>改良子树同构(Improved-Subtree-Isomorphism)</strong>，和字数同构算法一样，但不同在于我们在处理第10步时采用了不同的方法。设 $v$ 是 $G^r$ 中的一些节点，它们的孩子是 $v_1,\dots,v_t$，设 $u$ 是 $H$ 中的一个节点，它的孩子是 $u_1,\dots,u_s$。我们现在考虑找到一个 $B=B(v,u)$ 中的最大匹配。回忆起来 $B=(X,Y,E)$ 其中 $X=\lbrace u_1,\dots,u_s\rbrace$， $Y=\lbrace v_1,\dots,v_t\rbrace$。我们假设 $s\leq t+1$ （否则 $S(v,u)=\phi$）<br>我们首先应用引理3.3来构建一个 $B$ 的子图 $B’=(X’,Y’,E’)$，令其最大度为 $s$。然后，像在[16]中那样，我们将 $B’$ 的边划分到二部图 $C_1,\dots,C_p$ 中。我们按以下方法进行划分：首先，我们以字典序对 $X’$ 中的节点进行排序，其中节点 $u$ 的键值为 $N[u]$ 。然后，我们将 $X’$ 分成相同的键 $X^1,\dots,X^p$，（也即是说，所有的 $X^i$ 中的节点都在 $Y’$ 中由相同的邻居）。现在，对于所有的 $1\leq i\leq p$，我们设 $C_i$ 是去掉了 $X^i$ 节点的子图，并且它所有的邻居都在 $Y’$ 中。我们现在按照[16]中的方法构建一个网络 $B^\ast$，它的节点为 $V^\ast =X’\cup Y’ \cup \lbrace c_1,\dots,c_p,a,b\rbrace$。边为 $E^\ast =E_1\cup E_2$，其中有：<br>$$E_1=\lbrace au_i:u_i\in X’\rbrace \cup \lbrace v_ib:v_i \in Y’ \rbrace $$<br>$$E_2=\lbrace u_ic_j:j \leq p,u_i \in C_j\rbrace \cup \lbrace c_jv_i:j \leq p,v_i \in C_j \rbrace$$<br>所有的边的都有1的容量。源是$a$，汇聚到$b$。我们使用 Dinic 的算法在 $B^\ast$ 中找到一个最大流（积分），然后以此构建 $B’$ 中的最大匹配。（因为所有边的容量都是1，可以可以将流$f$分解为从$a$到$b$的边不相交路径，其中每条路径上的流为1。因为每一条路径都符合 $[a,u_i,c_k,v_j,b]$的格式，我们可以通过提出一条边 $u_iv_j$ 来对应那条路并定义 $B’$ 中的一个匹配。这种匹配的极大性来自于流的极大性。）<br>我们现在分析上述算法的时间复杂度。我们用 $D(u)$ 来表示在森林 $H^u_{u_1},\dots,H^u_{u_s}$ 中不同的树。</p><blockquote><p><strong>引理4.1</strong>：改良子树同构算法在 $B(v,u)$ 中找到一个最大匹配的时间在 $O(st+ts^{0.5}D(u))$ 以内。</p><blockquote><p><strong>证明</strong>：注意到如果对于某些 $i,j$，有根树$H^u_{u_i}$ 和 $H^u_{u_j}$ 是同构的，那么在 $B=B(v,u)$ 中节点 $u_i,u_j$ 完全拥有相同的邻居，并且在 $B’$ 中亦是如此（假设 $u_i$ 和 $u_j$ 在 $B’$ 中未被删去）。因此有 $p\leq D(u)$。<br>构造 $B,B’,B^\ast$ 的时间是 $O(st)$（我们使用基数排序对 $X’$ 节点进行排序）。我们现在限定了在 $B^\ast$ 中找到最大流的时间：$E_1$ 的大小为 $|{X’}|+|{Y’}|$，其中$|{X’}|\leq s$，$|{Y’}|\leq sp$ （因为每一个 $Y’$ 中节点拥有至少一条来自 $c_j$ 的边，不超过 $s$ 条边从每个顶点 $c_j$ 到$Y’$ 中的顶点）。$E_2$ 的大小至少是 $2sp$，因为 $E_2$ 中某顶点$c_j$上的入射边数最多为$|{X’}|+d_{B’}(u_i)\leq 2s$，其中 $u_i \in C_j$。因此，$B^\ast$ 中的边数为$O(sp)$。在$B^\ast$中的顶点数至多为$s+t+p+2=O(t)$，因为 $s\leq t+1$。现在，Dinic 的算法表现出$O(\sqrt{|{V^\ast}|})$ 的阶数，每一阶花费 $O(|{E^\ast}|)$ 的时间。因此，总时间复杂度为 $O(t^{0.5}sp)=O(ts^{0.5}p)=o(ts^{0.5}D(u))$</p></blockquote></blockquote><p>我们再次用 $V$ 表示 $\lbrace x_1,\dots,x_n\rbrace$，$V_H$ 表示 $\lbrace y_1,\dots,y_k\rbrace$。通过引理4.1，改良子树同构算法的时间复杂度为：<br>$$O(\displaystyle \sum^n_{i=1}{\displaystyle \sum^k_{j=1}{d(y_j)d(x_i)+d(x_i)d(y_j)^{0.5}D(y_j)}})=O(kn+n\displaystyle \sum^k_{j=1}{d(y_j)^{0.5}D(y_j)})$$<br>我们将限制求和 $\sum^k_{j=1}{d(y_j)^{0.5}D(y_j)}$ 到 $O(k^{1.5}/\log k)$。<br>我们首先需要一个简单的组合引理。令 $g(n)$ 表示 $n$ 个节点的不相同（也即是不同构）有根树的数量。我们可以使用以下结果：</p><blockquote><p><strong>引理4.2</strong>：$g(n)=2^{\Theta (n)}$</p></blockquote><p>设 $f(n)$ 表示最大的 $n$ 节点森林中的不同构有根树的数量。</p><blockquote><p><strong>引理4.3</strong>：$f(n)=\Theta (n/\log n)$</p><blockquote><p><strong>证明</strong>：为了展示下限，我们使用结论：对于足够大的 $n$ ，有$g(n) \geq 2^n$。 因此，不同的$l=\lfloor \log \frac{n}{\log n}\rfloor$节点有根树的数量$g(l)\geq 2^{\log \frac{n}{\log n}-1}=\frac{n}{2\log n}$。因此我们可以通过提出 $\lfloor \frac{n}{2\log n} \rfloor$ 个不同的拥有 $l$ 个节点的树俩构建森林，森林的总节点数是 $\lfloor \frac{n}{2\log n} \rfloor&lt;n$。因此 $f(n)=\Omega (\frac{n}{\log n})$。我们现在来讨论上限。<br>如果我们有一个有根树的森林，并且用 $r_i$ 来表示森林中拥有 $i$ 个节点的树的数量，那么不同的树的数量最多为 $\sum^n_{i=1}min(r_i,g(i))$。因此有：<br>$$f(n)\leq max\lbrace \displaystyle \sum^n_{i=1}{min(r_i,g(i)):r_1,\dots,r_n \in \mathbb{N},\displaystyle \sum^n_{i=1}{ir_i \leq n}} \rbrace$$<br>根据引理4.2，有：<br>$$f(n)\leq max\lbrace \displaystyle\sum^n_{i=1}{min(r_i,c^i):r_1,\dots,r_n\in \mathbb{N},\displaystyle\sum^n_{i=1}{ir_i}\leq n} \rbrace$$<br>对于一些整数常量 $c$。我们设 $x$ 是最小的整数，使得 $\sum^x_{i=1}{ic^i}\geq n$。设 $r_1,\dots,r_n$ 为在 $\sum^n_{1}{ir_i}\leq n$ 约束下使得 $\sum^n_{i=1}{min(r_i,c^i)}$ 最大化的一组值。我们可以假设 $r_i\leq c^i$ 对于所有 $i$ 成立，因为如果对于某些 $j$ 有 $r_j &gt; c^j$ 的话，我们可以设 $r_j=c^j$，然后 $\sum^n_{i=1}{min(r_i,c^i)}$ 的值并未改变。现在，考虑对于某些 $j&gt;x$ 的情况 $r_j&gt;0$。这表明存在一个 $k\leq x$ 使得 $r_k&lt;c^k$（否则 $\sum^n_{i=1}{ir_i}\geq \sum^x_{i=1}{ir_i+jr_j}=\sum^x_{i=1}{ic^i+jr_j}&gt;n$，矛盾）。如果我们将 $r_j$ 减一，$r_k$ 加一，$\sum^n_{i=1}{min(r_i,c^i)}$ 的值并未改变，而且限制条件 $\sum^n_{i=1}{ir_i}\leq n$ 仍然满足（因为$k&lt;j$）。我们可以重复这个过程直到 $r_j=0$ 对于所有的 $j&gt;x$ 都成立，因此有：<br>$$f(n)\leq\displaystyle\sum^n_{i=1}{min(r_i,c^i)}\leq\displaystyle\sum^x_{i=1}{c^i}=O(c^x)$$<br>这个引理根据以下结论得到：$x=\log_cn-\log_c\log_cn+O(1)$。</p></blockquote></blockquote><p>我们现在继续分析</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua应用</title>
      <link href="/2019/06/04/Lua%E5%BA%94%E7%94%A8/"/>
      <url>/2019/06/04/Lua%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>关于Lua脚本语言在太阳神三国杀中的应用<br><a id="more"></a></p><h1 id="基本了解"><a href="#基本了解" class="headerlink" title="基本了解"></a>基本了解</h1><h2 id="关于神杀"><a href="#关于神杀" class="headerlink" title="关于神杀"></a>关于神杀</h2><p>太阳神三国杀，是一款基于C++ QT GUI框架的三国杀非官方开源软件，开发者：Moligaloo（太阳神上），现在由Mogara团队继续维护源码。在实现游卡三国杀游戏规则的基础上，还拥有自己独特的功能和元素：原创技能卡牌配音；原创扩展包倚天、欢乐；原创扩展模式双将、剧情、闯关、国战等。拥有智能AI可以实现联机和单机的两种游戏方式，并能通过DIY接口进行自由的个性化修改和添加更多元素。  </p><h2 id="关于Lua"><a href="#关于Lua" class="headerlink" title="关于Lua"></a>关于Lua</h2><p>Lua是一个小巧的脚本语言。它是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo三人所组成的研究小组于1993年开发的。 其设计目的是为了通过灵活嵌入应用程序中从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。<br>Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，这使得Lua在应用程序中可以被广泛应用。不仅仅作为扩展脚本，也可以作为普通的配置文件，代替XML,ini等文件格式，并且更容易理解和维护。Lua由标准C编写而成，代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。<br>而神杀就可以通过lua来进行扩展包的添加</p><h1 id="上手操作"><a href="#上手操作" class="headerlink" title="上手操作"></a>上手操作</h1><h2 id="创建自己的扩展包"><a href="#创建自己的扩展包" class="headerlink" title="创建自己的扩展包"></a>创建自己的扩展包</h2><h3 id="创建扩展包"><a href="#创建扩展包" class="headerlink" title="创建扩展包"></a>创建扩展包</h3><p>在三国杀中，有许许多多的包，标准，风林火山，一将成名……那么我们能不能自己创建一个包呢？答案是可以的，我们新建一个lua文件。命名为自己想要的名称就可以了。例如，这次我们以<s>迫害</s>王强为例，建立一个王强包吧。为了方便，我们把包名定为wangqiang.lua，将文件建立在extensions文件夹中，并在里面添上以下代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module(<span class="string">"extensions.wangqiang"</span>, <span class="built_in">package</span>.<span class="built_in">seeall</span>)</span><br><span class="line">extension = sgs.Package(<span class="string">"wangqiang"</span>)</span><br></pre></td></tr></table></figure></p><p>这两句的通用格式为：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module(<span class="string">"extensions.扩展包名称"</span>,<span class="built_in">package</span>.<span class="built_in">seeall</span>)</span><br><span class="line">extension = sgs.Package(<span class="string">"扩展包名称"</span>)</span><br></pre></td></tr></table></figure></p><p>但是，游戏可不知道wangqiang代表什么文字，它只会一五一十的把wangqiang写上去，这可怎么办？这时候便需要一个翻译表，使用sgs.LoadTranslationTable来进行创建。格式如下：<br>[“原文”] = “译文”<br>两句之间用英文逗号分隔开来，例如：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sgs.LoadTranslationTable &#123;</span><br><span class="line">    [<span class="string">'wangqiang'</span>] = <span class="string">'王强包'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存之后我们进入游戏康康。<br><img src="/2019/06/04/Lua应用/王强包效果.png" alt="王强包效果"><br>哈哈快看，王强包在右下角看的清清楚楚。这样一来，王强包的添加就到此完成了。</p><h3 id="创建自己的新武将"><a href="#创建自己的新武将" class="headerlink" title="创建自己的新武将"></a>创建自己的新武将</h3><p>包有了，但里面是空的啊。这个时候，我们就要向里面装东西了。既然这次我们是以王强为例进行<s>迫害</s>。那么新武将就决定是王强了，和变量命名规则一样，我们以wangqiang作为其名称进行创建：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wangqiang = sgs.General(extension,<span class="string">"wangqiang"</span>,<span class="string">"ri"</span>,<span class="string">"4"</span>) <span class="comment">-- 这里的ri势力是自定义势力，不在本次的讨论范围内</span></span><br></pre></td></tr></table></figure></p><p>创建武将的函数原型如下：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sgs.General(</span><br><span class="line"><span class="built_in">package</span>,</span><br><span class="line">name,</span><br><span class="line">kingdom,</span><br><span class="line">max_hp=<span class="number">4</span>,</span><br><span class="line">male=<span class="literal">true</span>,</span><br><span class="line">hidden=<span class="literal">false</span>,</span><br><span class="line">never_shown=<span class="literal">false</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>翻译过来即是：<br>sgs.General(扩展包,姓名,国籍,体力上限,性别,是否隐藏,是否完全隐藏)<br>相关参数：</p><ol><li>package（扩展包）：统一写extension就行了。</li><li>name（姓名）：没忘刚才好不容易起的名字吧？wangqiang，就它了！另外，如果是主公武将，需要在名字后面加上$符号，来显示这个武将”超凡脱俗”的气质。比如曹操就是caocao$什么的。</li><li>kingdom（所属势力）：列在下面了——<br> ☆魏势力：wei<br> ☆蜀势力：shu<br> ☆吴势力：wu<br> ☆群雄势力：qun<br> ☆神武将：god<br>当然，出于特殊的<s>迫害</s>目的，王强的国籍是自定义的，这个不在这里讨论。  </li><li>max_hp（体力上限）：就是勾玉的数目，不写的话默认是4。</li><li>male（性别）：填true就是男性，填false就是女性，……什么都不写也是男性！(函数默认参数的知识点！)</li><li>hidden（是否隐藏）：填true就是隐藏了，填false就是不隐藏，默认当然是不隐藏了～</li><li>never_shown（是否完全隐藏）：依然是填true隐藏、填false或者默认是不隐藏。上面那个隐藏只是在游戏中不会被系统列在选将名单里，开自由选将的话还是能选到的（比如测试包里的五星诸葛亮）；这个完全隐藏可是连自由选将都没希望找到的，当然现在我们的游戏中还没有这样的武将就是了……  </li></ol><p>建立完成之后，不要忘记向翻译表里添加东西啊：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sgs.LoadTranslationTable &#123;</span><br><span class="line">    [<span class="string">'wangqiang'</span>] = <span class="string">'王强包'</span>,</span><br><span class="line">    [<span class="string">'Wangqiang'</span>] = <span class="string">'王强'</span>,</span><br><span class="line">    [<span class="string">'&amp;Wangqiang'</span>] = <span class="string">'王强'</span>,</span><br><span class="line">    [<span class="string">'designer:Wangqiang'</span>] = <span class="string">'王建军'</span>,</span><br><span class="line">    [<span class="string">'illustrator:Wangqiang'</span>] = <span class="string">'王强'</span>,</span><br><span class="line">    [<span class="string">'#Wangqiang'</span>] = <span class="string">'猪精'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中：<br>[“武将名称”] 就是对武将本身名字的翻译；<br>[“&amp;武将名称”]是游戏中显示的武将名字，比如☆SP貂蝉在游戏中显示为“貂蝉”而没有那些前缀，就是这里规定的；<br>[“#武将名称”] 则是对武将称号的翻译，像☆SP貂蝉的称号“暗黑的傀儡师”之类的都是在这里添加的。<br>另外，武将设计者的名字由 [“designer:武将名称”] 提供，不写的话默认为“官方”。还不快快签上自己的大名？<br>武将台词配音者的名字由 [“cv:武将名称”] 提供，默认为”官方”；武将插画绘制者的名字由 [“illustrator:武将名称”] 提供，默认为”KayaK”。可以在武将一览的右上角看到这三部分的信息。<br>添加完毕，我们进入游戏康康吧：<br><img src="/2019/06/04/Lua应用/王强包王强.png" alt="王强包效果"><br>好，王强就这样被安排的明明白白。</p><h3 id="武将美化"><a href="#武将美化" class="headerlink" title="武将美化"></a>武将美化</h3><p>额，关于武将牌面的制作，这里就不多讲了。</p><h3 id="添加技能"><a href="#添加技能" class="headerlink" title="添加技能"></a>添加技能</h3><p>王强总归现在是个白板，玩起来No行，怎么办呢，我们可以添加技能进去。这样一来有2个方案：1. 添加游戏中已有技能 2. 自己动手写技能。我们首先介绍一下如何为武将添加技能，添加技能有一个函数，它有两个原型：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addSkill(skill)</span><br><span class="line">addSkill(skill_name)</span><br></pre></td></tr></table></figure></p><p>其中skill是一个技能对象，而skill_name是一个字符串，引用一个已存在的技能，例如，为我们的王强添加一个技能“耀武”的代码如下：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wangqiang:addSkill(<span class="string">"yaowu"</span>)</span><br></pre></td></tr></table></figure></p><p><em>耀武: 锁定技，当一名角色使用【杀】对你伤害时，若之为：红色，来源选择是否回复1点体力，若其选择否，其摸一张牌；不为红色，你摸一张牌。 </em><br>因为是引用的别人的技能(华雄)，所以使用带引号的技能名称，但是终究不过瘾，我们能不能自己写技能呢，答案当然是可以的。</p><h3 id="创建自己的技能"><a href="#创建自己的技能" class="headerlink" title="创建自己的技能"></a>创建自己的技能</h3><h4 id="技能类型"><a href="#技能类型" class="headerlink" title="技能类型"></a>技能类型</h4><p>神杀中的技能类型大约有以下几类：</p><ul><li>视为技(ViewAsSkill)</li><li>触发技(TriggerSkill)</li><li>禁止技(ProhibitSkill)</li><li>距离修改技(DistanceSkill)</li><li>手牌上限技(MaxCardsSkill)</li><li>锁定视为技(FilterSkill)</li><li>目标模式技(TargetModSkill)</li></ul><h5 id="视为技"><a href="#视为技" class="headerlink" title="视为技"></a>视为技</h5><p>简单来讲，视为技能就是将X张手牌视作X技能的技能卡使用，实现相关的效果。以界孙权的技能制衡为例：<br><em>制衡: 出牌阶段限一次，你可以弃置至少一张牌，然后若你以此法弃置了所有手牌，你摸X+1张牌，否则你摸X张牌。（X为你以此法弃置的牌数） </em><br>翻译过来就是：出牌阶段限一次，你可以弃置X张牌，视作你使用了1张“制衡技能卡”。而技能卡则是这样的：<br><em>制衡技能卡：你摸Y张牌(若你以此法弃置了所有手牌，则Y=X+1，否则Y=X)</em><br>如此一来，许多技能即是由这种技能卡所堆积而成的了。</p><h5 id="触发技"><a href="#触发技" class="headerlink" title="触发技"></a>触发技</h5><p>触发技其实在三国杀里比较常见，通常是以阶段触发技为主，例如貂蝉的“闭月”：<br><em>闭月: 结束阶段开始时，你可以摸X张牌。（若你没有手牌，X为2，否则X为1）</em><br>这就是一个典型的触发技，当进入到你的结束阶段时，触发技能效果。你摸X张牌，而X的值由你的手牌数而定。</p><h5 id="禁止技"><a href="#禁止技" class="headerlink" title="禁止技"></a>禁止技</h5><p>禁止技的效果是不能成为某种牌的目标。例如：贾诩的“帷幕”：<br><em>帷幕: 锁定技，你不是黑色锦囊牌的合法目标。</em><br>通常来讲，在确定目标时，就已经进行了判断，与于禁的“毅重”不同，于禁的“毅重”是打出了黑色杀之后，再触发技能。也就是说，假如于禁和贾诩单挑，于禁有一张黑色的【过河拆桥】，那么于禁是不能打出这张牌的（因为没有合法目标），而如果贾诩有黑色的【杀】则可以指定于禁为目标，但是会触发“毅重”的效果，终止【杀】的结算。<br><em>毅重: 锁定技，若你的装备区里没有防具牌，黑色【杀】对你无效。</em></p><h5 id="距离修改技"><a href="#距离修改技" class="headerlink" title="距离修改技"></a>距离修改技</h5><p>距离修改技即是修改玩家之间的技能，熟悉的便是“马术”“飞影”以及白马公孙瓒的“义从”了：<br><em>马术: 锁定技，你与其他角色的距离-1。</em><br><em>飞影: 锁定技，其他角色与你的距离+1</em><br><em>义从: 锁定技，若你的体力值：大于2，你与其他角色的距离-1；不大于2，其他角色与你的距离+1。</em>  </p><h5 id="手牌上限技"><a href="#手牌上限技" class="headerlink" title="手牌上限技"></a>手牌上限技</h5><p>顾名思义，这个技能可以修改你的手牌上限。<br>有增加上限的，例如刘表的“宗室”：<br><em>宗室: 锁定技，你的手牌上限+X。（X为势力数）</em><br>也有固定上限的，例如新版周泰的“不屈”：<br><em>不屈: 锁定技，当你处于濒死状态时，你将牌堆顶的一张牌置于武将牌上，称为“创”，然后若此“创”与其他“创”点数均不同，你将体力值回复至1点，否则你将此“创”置入弃牌堆；锁定技，若有“创”，你的手牌上限为X（X为“创”数）。</em><br>技能的第二个效果即是固定手牌上限了。</p><h5 id="锁定视为技"><a href="#锁定视为技" class="headerlink" title="锁定视为技"></a>锁定视为技</h5><p>这个其实与视为技类似，只不过多了强制性，例如神关羽的“武神”：<br><em>武神: 锁定技，你的红桃手牌视为【杀】；锁定技，你使用红桃【杀】无距离限制。</em><br>对比普通关羽的“武圣”：<br><em>武圣: 你可以将一张红色牌当【杀】使用或打出。</em><br>很明显，这是锁定技，也就是说，神关羽的红桃手牌不能自由地控制它的属性，只能当作【杀】打出，而关羽则可以根据需要将红色手牌以不同的牌面进行使用。  </p><h5 id="目标模式技"><a href="#目标模式技" class="headerlink" title="目标模式技"></a>目标模式技</h5><p>这个技能类型即是规定了使用牌的目标，例如：虎牢关吕布的“神戟”既是一个典型的例子：<br><em>神戟: 若你的装备区里没有武器牌，你使用【杀】的额外目标数上限+2。</em><br>平常的【杀】只能杀1个人，但是通过这种技能，我们可以指定多名角色为目标。</p><h5 id="实例-王强技能"><a href="#实例-王强技能" class="headerlink" title="实例-王强技能"></a>实例-王强技能</h5><p>那么我们为王强设计的技能如下：<br><em>为情所困: 锁定技，限定技，准备阶段开始时，若场上存在女性角色且你的体力上限大于2，则你减体力上限至2。锁定技，你不是【决斗】【南蛮入侵】【万箭齐发】【杀】的合法目标。</em><br>将技能拆开来看，既是一个触发技和一个禁止技的结合。于是我们可以创建两个技能，再将其中一个进行隐藏。我们首先进行禁止技的创建吧：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LuaWeiqingsuokunPro = sgs.CreateProhibitSkill &#123;</span><br><span class="line">    name = <span class="string">'LuaWeiqingsuokunPro'</span>,</span><br><span class="line">    is_prohibited = <span class="function"><span class="keyword">function</span><span class="params">(self, from, to, card)</span></span></span><br><span class="line">        <span class="keyword">if</span> to:hasSkill(<span class="string">'LuaWeiqingsuokunPro'</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> card:isKindOf(<span class="string">'Duel'</span>) <span class="keyword">or</span> card:isKindOf(<span class="string">'Slash'</span>) <span class="keyword">or</span> card:isKindOf(<span class="string">'SavageAssault'</span>) <span class="keyword">or</span></span><br><span class="line">                card:isKindOf(<span class="string">'ArcheryAttack'</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来似乎有点长啊，但实际上并不复杂，类似的我们以C/C++的语法也能理解它。首先是创建了一个名为LuaWeiqingsuokunPro的禁止技技能对象。它的名称(name)是LuaWeiqingsuokunPro，而is_prohibited即是判断准则，card是目标卡牌，return card:isKindOf(“卡牌类型”)即是不能成为此种卡牌的目标。具体的卡牌名称可以在lang文件夹下进行查阅，注意要把下划线去掉并且做好大小写区分。例如，当一名角色准备使用【决斗】指定目标时，这个时候card就是Duel，而这个function返回的值就是true，那么is_prohibited就是true了。王强就不能被选中成为这张【决斗】的目标了。<br>那么接下来，我们实现第一个功能吧：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LuaWeiqingsuokun = sgs.CreateTriggerSkill &#123;</span><br><span class="line">    name = <span class="string">'#LuaWeiqingsuokun'</span>,</span><br><span class="line">    frequency = sgs.Skill_Compulsory,</span><br><span class="line">    events = &#123;sgs.EventPhaseStart&#125;,</span><br><span class="line">    on_trigger = <span class="function"><span class="keyword">function</span><span class="params">(self, event, player, data)</span></span></span><br><span class="line">        <span class="keyword">local</span> room = player:getRoom()</span><br><span class="line">        <span class="keyword">if</span> player:getPhase() == sgs.Player_Start <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> player:getMark(<span class="string">'LuaQingkun'</span>) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> player:getMaxHp() &gt; <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> others = room:getOtherPlayers(player)</span><br><span class="line">                    <span class="keyword">for</span> _, target <span class="keyword">in</span> sgs.qlist(others) <span class="keyword">do</span></span><br><span class="line">                        <span class="keyword">if</span> target:isFemale() <span class="keyword">then</span></span><br><span class="line">                            room:sendCompulsoryTriggerLog(player, self:objectName())</span><br><span class="line">                            room:loseMaxHp(player, player:getMaxHp() - <span class="number">2</span>)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    room:addPlayerMark(player, <span class="string">'LuaQingkun'</span>)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>唔，看起来有点长，我们进行一下拆分吧<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LuaWeiqingsuokun = sgs.CreateTriggerSkill &#123;</span><br><span class="line">    name = <span class="string">'#LuaWeiqingsuokun'</span>,</span><br><span class="line">    frequency = sgs.Skill_Compulsory,</span><br><span class="line">    events = &#123;sgs.EventPhaseStart&#125;,</span><br><span class="line">    on_trigger = <span class="function"><span class="keyword">function</span><span class="params">(self, event, player, data)</span></span></span><br><span class="line">       <span class="comment">-- statements</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些是触发技的基本要素：名称（name）、类型（发动频率/frequency）、响应事件（events）、触发的动作（on_trigger）还有就是省略的<br>能否触发（can_trigger），它的默认值是存活且拥有本技能，所以未列出。这里的技能名称前面加了#符号，代表不会占用技能格，也就是没有技能按钮。<br>好了，王强的技能是锁定技，那么使用枚举类型sgs.Skill_Compulsory进行定义。查看源码可以看到所有的技能类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skill</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">enum</span> Frequency&#123;</span><br><span class="line">        Frequent,<span class="comment">// 默认触发技</span></span><br><span class="line">        NotFrequent,<span class="comment">// 询问触发技</span></span><br><span class="line">        Compulsory,<span class="comment">// 锁定技</span></span><br><span class="line">        Limited,<span class="comment">// 限定技</span></span><br><span class="line">        Wake<span class="comment">// 觉醒技</span></span><br><span class="line">    &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>即是对应的，默认触发技(符合条件时自动选择触发，可以更改为每次询问)，每次询问的触发技，锁定技（符合条件直接执行），限定技，觉醒技<br>那么王强的是一个限定技，我们只需要加入触发一次之后不再次触发的条件就好了。我们使用标签来判断王强有没有执行过判断吧。不过首先要判断是否处于准备阶段，我们使用getPhase()来获取玩家当前的阶段。同样，它也有一些枚举值，我在此列出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Phase &#123;RoundStart, Start, Judge, Draw, Play, Discard, Finish, NotActive, PhaseNone&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分别对应：回合开始、准备阶段、判定阶段、摸牌阶段、出牌阶段、弃牌阶段、结束阶段、回合外、空阶段<br>但是光有玩家还是不够的，我们需要帮手来完成一系列的操作，它就是游戏的“房主”房间room。我们首先获取玩家的room，再利用room为所欲为：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">on_trigger = <span class="function"><span class="keyword">function</span><span class="params">(self, event, player, data)</span></span></span><br><span class="line">        <span class="keyword">local</span> room = player:getRoom()</span><br><span class="line">        <span class="keyword">if</span> player:getPhase() == sgs.Player_Start <span class="keyword">then</span>  <span class="comment">-- 如果是准备阶段</span></span><br><span class="line">            <span class="keyword">if</span> player:getMark(<span class="string">'LuaQingkun'</span>) == <span class="number">0</span> <span class="keyword">then</span><span class="comment">-- 如果LuaQingkun标记数为0</span></span><br><span class="line">                <span class="keyword">if</span> player:getMaxHp() &gt; <span class="number">2</span> <span class="keyword">then</span><span class="comment">-- 体力上限大于2才接着进行下面的操作</span></span><br><span class="line">                    <span class="keyword">local</span> others = room:getOtherPlayers(player)<span class="comment">-- 获取其他的玩家列表</span></span><br><span class="line">                    <span class="keyword">for</span> _, target <span class="keyword">in</span> sgs.qlist(others) <span class="keyword">do</span><span class="comment">-- 遍历其他的玩家</span></span><br><span class="line">                        <span class="keyword">if</span> target:isFemale() <span class="keyword">then</span><span class="comment">-- 如果玩家性别为女</span></span><br><span class="line">                            room:sendCompulsoryTriggerLog(player, self:objectName())<span class="comment">-- 显示消息（X玩家的“为情所困”被触发）</span></span><br><span class="line">                            room:loseMaxHp(player, player:getMaxHp() - <span class="number">2</span>)<span class="comment">-- 失去对应的体力上限值</span></span><br><span class="line">                            <span class="keyword">break</span><span class="comment">-- 因为已经找到了女性，没有继续遍历的必要了，跳出循环</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    room:addPlayerMark(player, <span class="string">'LuaQingkun'</span>)<span class="comment">-- 添加一个LuaQingkun标记，防止重复进行</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>好了，我们进入游戏看看效果吧。<br>看这个袁绍用的【万箭齐发】根本伤不到王强，真的太逊了。（王强：这个袁绍就是逊啦）<br><img src="/2019/06/04/Lua应用/为情所困效果1.png" alt="为情所困效果"><br>士兵（女）：听你这么说，你很勇哦。<br><img src="/2019/06/04/Lua应用/士兵女.png" alt="士兵女"><br>哦豁，场上有女角色出现了！到了王强的回合……<br><img src="/2019/06/04/Lua应用/为情所困效果2.png" alt="为情所困效果"><br>噔 噔 咚 ，王强现在只有2点体力上限了，真是太不幸了。<br>那么，到这里为止，本次的解说<s>迫害</s>也就到此结束了。</p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记七</title>
      <link href="/2019/05/30/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/"/>
      <url>/2019/05/30/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<p>关于内联函数和引用变量的一些内容<br><a id="more"></a></p><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><h3 id="什么是内联函数？"><a href="#什么是内联函数？" class="headerlink" title="什么是内联函数？"></a>什么是内联函数？</h3><p>内联函数是C++为提高程序运行速度所做的一项改进，常规函数和内联函数的主要区别不在于编写方式。而在于编译器如何将它们组合到程序中。  </p><h3 id="程序的运行过程"><a href="#程序的运行过程" class="headerlink" title="程序的运行过程"></a>程序的运行过程</h3><p>编译过程的最终产物是可执行程序——由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时(例如循环/分支语句)，将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址(函数的地址)，并在函数结束后返回。下面更详细地介绍这一过程。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数复制到堆栈(为此保留的内存块)，跳到标记函数起点的内存单元，执行函数代码(也许还需将返回值放入到寄存器中)，然后跳回到地址被保存的指令处(这与阅读文章时停下来看脚注，并在阅读完脚注后返回以前阅读的地方类似)。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。  </p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替代函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。<br>应有选择地使用内联函数。如果执行函数代码地时间比处理函数调用机制的时间长，则节省的时间将只占整个过程中很小的一部分。如果代码执行时间很短，那么内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非其经常被调用。<br>要使用这项特性，必须采取下述措施之一：</p><ul><li>在函数声明前加上关键字inline；</li><li>在函数定义前加上关键字inline。</li></ul><p>通常的做法是省略原型，将整个定义(即函数头和所有函数代码)放在本应提供原型的地方。<br>当然，内联函数只是对编译器的一种建议，编译器完全可以忽略你的建议。如果提供的函数过大或是调用了自己(内联函数不能递归)，编译器可能不会将其作为内联函数。<br>下面是一个实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline.cpp -- using an inline function</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// an inline function definition</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> a, b;</span><br><span class="line"><span class="keyword">double</span> c = <span class="number">13.0</span>;</span><br><span class="line"></span><br><span class="line">a = square(<span class="number">5.0</span>);</span><br><span class="line">b = square(<span class="number">4.5</span> + <span class="number">7.5</span>);<span class="comment">// can pass expressions</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", c squared = "</span> &lt;&lt; square(c++) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Now c = "</span> &lt;&lt; c &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它通过内联函数square()(计算参数的平方)演示了内联技术。注意到整个函数定义都放在一行中，但不一定非要这样做。然而，如果函数定义占用多行(假定没有使用冗长的标识符)，则将其作为内联函数就不大合适。<br>下面是该程序的输出：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">25</span>, b = <span class="number">144</span></span><br><span class="line">c = <span class="number">13</span>, c squared = <span class="number">169</span></span><br><span class="line">Now c = <span class="number">14</span></span><br></pre></td></tr></table></figure></p><p>输出表明，内联函数与常规函数一样，也是按值来传递参数的。如果参数为表达式，如上面的4.5+7.5，则函数将传递表达式的值(这里为12)。这使得C++的内联功能远远胜过C语言的宏定义。<br>尽管函数没有提供独立原型，但C++原型特性仍在起作用。这是因为在函数首次使用前出现的整个函数定义充当了原型。这意味着可以给square()传递int或long值，将值传递给函数前，程序自动将这个值强制转换为double类型。</p><h4 id="内联与宏"><a href="#内联与宏" class="headerlink" title="内联与宏"></a>内联与宏</h4><p>inline工具是C++新增的特性。C语言使用预处理器语句#define来提供宏——内敛代码的原始实现。例如，下面是一个计算平方的宏：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br></pre></td></tr></table></figure></p><p>这并不是通过传递参数实现的，而是通过文本替换实现的——X是“参数的符号标记”。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = SQUARE(<span class="number">5.0</span>); is replaced by a = <span class="number">5.0</span> * <span class="number">5.0</span>;</span><br><span class="line">b = SQUARE(<span class="number">4.5</span>+<span class="number">7.5</span>); is replaced by b = <span class="number">4.5</span> + <span class="number">7.5</span> * <span class="number">4.5</span> + <span class="number">7.5</span>;</span><br><span class="line">d = SQUARE(c++); is replaced by d = c++ * c++;</span><br></pre></td></tr></table></figure></p><p>上述示例只有第一个能正常工作。可以通过括号来改进：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) ((X)*(X))</span></span><br></pre></td></tr></table></figure></p><p>但仍然存在这样的问题，即宏不能按值传递。即使使用新的定义，SQUARE(C++)仍将c递增2次，但是之前的inline.cpp中的内联函数square()计算c的结果，传递它，以计算其平方值，然后将c递增一次。<br>这里的目的不是演示如何编写C宏，而是要指出，如果使用C语言的宏执行了类似函数的功能，应考虑将它们转换为C++内联函数。</p><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>C++新增了一种复合类型——引用变量。引用是一顶一的变量的别名(另一个名称)。例如，如果将twain作为element变量的引用，则可以交替使用twain和element来表示该变量。那么，这种别名有何作用呢？它的主要作用是用作函数的形参，通过引用变量作为参数，函数将使用原始数据，而不是其副本。这样，除指针以外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。</p><h4 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h4><p>C和C++使用&amp;符号来表示变量的地址。C++给&amp;符号赋予了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量的别名，可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rats;</span><br><span class="line"><span class="keyword">int</span> &amp; rodents = rats;<span class="comment">// makes rodents an alias for rats</span></span><br></pre></td></tr></table></figure></p><p>其中，&amp;不是地址运算符，而是类型标识符的一部分。就像声明中的char*指的是指向char的指针一样，int &amp;指的是指向int的引用。上述引用声明允许将rats和rodents呼唤——它们指向相同的值和内存单元，参看以下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// firstref.cpp -- defining and using a reference</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> rats = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; rodents = rats;<span class="comment">// rodents is a reference</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rats = "</span> &lt;&lt; rats;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", rodents = "</span> &lt;&lt; rodents &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">rodents++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rats = "</span> &lt;&lt; rats;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", rodents = "</span> &lt;&lt; rodents &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some implementations require type casting the following</span></span><br><span class="line"><span class="comment">// addresses to type unsigned</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rats address = "</span> &lt;&lt; &amp;rats;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", rodents address = "</span> &lt;&lt; &amp;rodents &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，下述语句中的&amp;运算符不是地址运算符，而是将rodents的类型声明为int &amp;，即指向int变量的引用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; rodents = rats;</span><br></pre></td></tr></table></figure></p><p>不过，下述语句中的&amp;则是地址运算符，其中&amp;rodents表示rodents引用的变量的地址：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", rodents address = "</span> &lt;&lt; &amp;rodents &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>下面是上述程序的输出：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rats = 101, rodents = 101</span><br><span class="line">rats = 102, rodents = 102</span><br><span class="line">rats<span class="built_in"> address </span>= 0x0065fd48, rodents<span class="built_in"> address </span>= 0x0065fd48</span><br></pre></td></tr></table></figure></p><p>从中可知，rats和rodents的值和地址都相同(具体的地址和显示格式随系统而异)。将rodents加1将影响这两个变量。更准确地说，rodents++操作将一个有两个名称的变量加1。</p><h4 id="将引用作为函数参数"><a href="#将引用作为函数参数" class="headerlink" title="将引用作为函数参数"></a>将引用作为函数参数</h4><p>引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法成为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。C++新增的这项特性是对C语言的超越，C语言只能按值传递。按值传递导致被调用函数使用调用程序的值的拷贝。当然，C语言也允许避开按值传递的限制，采用按指针传递的方式。<br>参看下列程序代码，它演示了几种交换两个变量的值的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swaps.cpp -- swapping with references and with pointers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapr</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;<span class="comment">// a, b are aliases for ints</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapp</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span>;<span class="comment">// p, q are addresses of ints</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapv</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;<span class="comment">// a,b are new variables</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> wallet1 = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> wallet2 = <span class="number">350</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wallet1 = $"</span> &lt;&lt; wallet1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" wallet2= $"</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Using reference to swap contents:\n"</span>;</span><br><span class="line">swapr(wallet1, wallet2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wallet1 = $"</span> &lt;&lt; wallet1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" wallet2= $"</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Using pointers to swap contents again:\n"</span>;</span><br><span class="line">swapp(&amp;wallet1, &amp;wallet2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wallet1 = $"</span> &lt;&lt; wallet1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" wallet2= $"</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to use passing by value:\n"</span>;</span><br><span class="line">swapv(wallet1, wallet2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wallet1 = $"</span> &lt;&lt; wallet1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" wallet2= $"</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapr</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span><span class="comment">// use references</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = a;<span class="comment">// use a, b for values of variables</span></span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapp</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span><span class="comment">// use pointers</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = *p;<span class="comment">// use *p, *q for values of variables</span></span><br><span class="line">*p = *q;</span><br><span class="line">*q = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapv</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><span class="comment">// try using values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是程序的输出：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wallet1 = $30<span class="number">0</span> wallet2 = $35<span class="number">0</span>&lt;&lt; original <span class="keyword">values</span></span><br><span class="line">Using references to swap contents:</span><br><span class="line">wallet1 = $35<span class="number">0</span> wallet2 = $30<span class="number">0</span>&lt;&lt; <span class="keyword">values</span> swapped</span><br><span class="line">Using pointers to swap contents:</span><br><span class="line">wallet1 = $30<span class="number">0</span> wallet2 = $35<span class="number">0</span>&lt;&lt; <span class="keyword">values</span> swapped again</span><br><span class="line">Trying to <span class="keyword">use</span> passing by value:</span><br><span class="line">wallet1 = $30<span class="number">0</span> wallet2 = $35<span class="number">0</span>&lt;&lt; swap failed</span><br></pre></td></tr></table></figure></p><p>正如预想那样，指针和引用方法都成功地交换了两个钱夹(wallet)中的内容，而按值传递的方法没能完成此项任务。<br>引用的其他使用方法我们将在后续学习。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记六</title>
      <link href="/2019/05/05/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
      <url>/2019/05/05/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<p>关于函数的一些内容<br><a id="more"></a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>没有返回值的函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">statement(s)</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">// optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，parameterList指定了传递给函数的参数类型与数量。<br>有返回值的函数将生成一个值，并将它返回给调用函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">typeName <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">statements</span><br><span class="line"><span class="keyword">return</span> value;<span class="comment">// value is type cast to type typeName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果函数包括多条返回语句，则在执行第一条返回语句时结束。</p><h3 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h3><p>考虑如下函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span><span class="comment">// arr = array name, n = size</span></span></span><br></pre></td></tr></table></figure></p><p>这看起来非常合理。方括号指出arr是一个数组，而方括号为空表明，可以将任意长度的数组传递给此函数。但实际上，arr并不是一个数组，而是一个指针。不过，在编写函数时，可以将arr看作是数组。  </p><h4 id="函数如何使用指针处理数组"><a href="#函数如何使用指针处理数组" class="headerlink" title="函数如何使用指针处理数组"></a>函数如何使用指针处理数组</h4><p>在大多数情况下，C++和C语言一样，将数组名视为指针。C++将数组名解释为第一个元素地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookies == &amp;cookies[<span class="number">0</span>];<span class="comment">// array name is address of first element</span></span><br></pre></td></tr></table></figure><p><strong>注意：只有当用于函数头或者函数原型时，int *arr和 int arr[]的含义才是相同的</strong><br>下列的恒等式值得记忆：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[i] == *(arr + i)</span><br><span class="line">&amp;arr[i] == arr + i</span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a>填充数组</h6><p>用于接受数组名参数的函数访问的是原始数组，而非其副本，因此可以通过调用该函数将值赋给数组元素。该函数的一个参数是要填充的数组名称。通常，不能在函数中设置数组长度，而要将数组长度作为第二个参数传递。由于用户输入的元素数目可能少于数组长度，因此函数应该返回实际输入的元素数目。因此，函数原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> ar[], <span class="keyword">int</span> limit)</span></span>;</span><br></pre></td></tr></table></figure></p><p>可以使用循环连续地将值读入到数组中，但如何提早结束呢？一种方法是，使用一个特殊值来指出输入结束。由于所有属性非负，可以使用负数来指出输入结束。另外，该函数应对错误输入作出反应，如停止输入等。这样，函数如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> ar[], <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> temp;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter value #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">cin</span>)<span class="comment">// bad input</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>.clear();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; input process terminated.\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">ar[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="显示数组及用const保护数组"><a href="#显示数组及用const保护数组" class="headerlink" title="显示数组及用const保护数组"></a>显示数组及用const保护数组</h6><p>为防止函数无意中修改数组的内容，可在声明形参时使用关键字const：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p><p>该声明表明，指针ar指向的是常量数据。这意味着不能使用ar修改该数据，也就是说，可以使用像ar[0]这样的值，但不能修改。下面是show_array()函数的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ar[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h6><p>在这个例子中，对数组进行的第三项操作是将每个元素与同一个重新评估因子相乘。需要给函数传递3个参数：因子、数组和元素数目。该函数不需要返回值，因此其代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">(<span class="keyword">double</span> r; <span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">ar[i] *= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于此函数将修改数组的值，因此在声明ar时，不能使用const。</p><h5 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h5><p>可以用两种不同方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值。第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。下面来看细节。首先，声明一个指向常量的指针pt：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">39</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;age;</span><br></pre></td></tr></table></figure></p><p>该声明指出，pt指向一个const int(这里为39)，因此不能使用pt来修改这个值。换句话来说，*pt的值为const，不能被修改：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt +=<span class="number">1</span>;<span class="comment">// INVALID because pt points to a const int</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; *pt;<span class="comment">// INVALID for the same reason</span></span><br></pre></td></tr></table></figure></p><p>现在有一个微妙的问题。pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt指向age，而age不是const。可以直接通过age变量来修改age的值，不能使用pt指针来修改它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt = <span class="number">20</span>;<span class="comment">// INVALID because pt points to a const int</span></span><br><span class="line">age = <span class="number">20</span>;<span class="comment">// VALID because age is not declared to be const</span></span><br></pre></td></tr></table></figure></p><p>以前我们将常规变量的地址赋给常规指针，而这里将常规变量的地址赋给const的指针。因此还有两种可能：将const变量的地址赋给const的指针、将const的地址赋给常规指针。这两种操作都可行吗？第一种可行，但第二种不可行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> g_earth = <span class="number">9.80</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> * pe = &amp;g_earth;<span class="comment">// VALID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> g_moon = <span class="number">1.63</span>;</span><br><span class="line"><span class="keyword">float</span> *pm = &amp;g_moon;<span class="comment">// INVALID</span></span><br></pre></td></tr></table></figure></p><p>对于第一种情况来说，既不能使用g_earth来修改值9.80，也不能使用pe来修改。C++禁止第二种情况的原因很简单——如果将g_moon的地址赋给pm，则可以使用pm来修改g_moon的值，这使得g_moon的const状态很荒谬，因此C++禁止将const的地址赋给非const指针。如果非要这样做，可以使用强制类型转换来突破限制，详情在之后讨论运算符const_cast是会提到。<br>如果将指针指向指针，则情况将更复杂。前面讲过，假如涉及的是一级间接关系，则将非const指针赋给const指针是可以的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">39</span>;<span class="comment">// age++ is a valid operation</span></span><br><span class="line"><span class="keyword">int</span> * pd = &amp;age;<span class="comment">// *pd = 41 is a valid operation</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = pd;<span class="comment">// *pt = 42 is an invalid operation</span></span><br></pre></td></tr></table></figure></p><p>然而，进入两级间接关系时，与一级间接关系一样，将const和非const混合的指针赋值方式将不再安全。如果允许这样做，则可以编写这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> **pp2;</span><br><span class="line"><span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">13</span>;</span><br><span class="line">pp2 = &amp;p1;<span class="comment">// not allowed, but suppose it were</span></span><br><span class="line">*pp2 = &amp;n;<span class="comment">// valid, but sets p1 to point at n</span></span><br><span class="line">*p1 = <span class="number">10</span>;<span class="comment">// valid, but changes const n</span></span><br></pre></td></tr></table></figure></p><p>上述代码将非const地址(&amp;p1)赋给了const指针(pp2)，因此可以使用p1来修改const数据。因此，当且仅当只有一层间接关系(如指针指向基本数据类型)时，才可以将非const地址或指针赋给const指针。<br><strong>注意：如果数据类型本身并不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针。</strong><br>假设有一个由const地址组成的数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> months[<span class="number">12</span>] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>则禁止将常量数组的地址赋给非常量指针将意味着不能将数组名作为参数传递给使用非常量形参的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;<span class="comment">// should have been const int arr[]</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> j = sum(months, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></p><p>上述函数调用试图将const指针(months)赋给非const指针(arr)，编译器将禁止这种函数调用。</p><h6 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h6><p>将指针参数声明为指向常量数据的指针有两条理由：</p><ul><li>这样可以避免由于无意间修改数据而导致的编程错误；</li><li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。如果条件允许，则应将指针形参声明为指向const的指针。</li></ul><p>为说明另一个微妙之处，请看下面的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">39</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;age;</span><br></pre></td></tr></table></figure></p><p>第二个声明中的const只能防止修改pt指向的值(这里为39)，而不能防止修改pt的值。也就是说，可以将一个新地址赋给pt：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sage = <span class="number">80</span>;</span><br><span class="line">pt = &amp;sage;<span class="comment">// okay to point to another location</span></span><br></pre></td></tr></table></figure></p><p>但仍然不能使用pt来修改它指向的值(现在为80)。<br>第二种使用const的方式使得无法修改指针的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sloth = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ps = &amp;sloth;<span class="comment">// a pointer to const int</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> finger = &amp;sloth;<span class="comment">// a const pointer to int</span></span><br></pre></td></tr></table></figure></p><p>在最后一个声明中，关键字const的位置与以前不同。这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。简而言之，finger和*ps都是const，而*finger和ps不是。<br>如果愿意，还可以声明指向const对象的const指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> trouble = <span class="number">2.0E30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> stick = &amp;trouble;</span><br></pre></td></tr></table></figure></p><p>其中，stick只能指向trouble，而stick不能用来修改trouble的值。简而言之，stick和*stick都是const。<br>通常，将指针作为函数形参来传递时，可以使用指向const的指针来保护数据。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p><p>在该声明中使用const意味着show_array()不能修改传递给它的数组中的值。只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针，则不能使用const。  </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记五</title>
      <link href="/2019/05/02/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
      <url>/2019/05/02/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<p>关于文件I/O的一些内容<br><a id="more"></a></p><h2 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入/输出"></a>简单文件输入/输出</h2><h3 id="文本I-O和文本文件"><a href="#文本I-O和文本文件" class="headerlink" title="文本I/O和文本文件"></a>文本I/O和文本文件</h3><p>我们这里讨论一下关于文本I/O的概念。当我们使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。不管目标数据类型是什么，输入一开始都是字符数据——文本数据。然后，cin对象负责将文本转换为其他类型。例如：<br>假设有如下输入行：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">38<span class="selector-class">.5</span> 19<span class="selector-class">.2</span></span><br></pre></td></tr></table></figure></p><p>首先，我们看一下char数据类型的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br></pre></td></tr></table></figure></p><p>输入行中的第一个字符被赋给ch。这里，第一个字符为3，其字符编码(二进制)被存储在变量ch中。输入和目标变量都是字符，因此不需要进行转换。注意，这里存储的数值3，而是字符3的编码。执行上述输入语句后，输入队列的下一个字符为字符8，下一个输入操作将对其进行处理。<br>接下来康康int类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br></pre></td></tr></table></figure></p><p>在这种情况下，cin将不断读取，直到遇到非数字字符。也即是，它将读取3和8，这样句点将成为输入队列的下一个字符，cin通过计算发现，这两个字符对应数值38，因此将38的二进制编码复制到变量n中。<br>接下来便是double类型了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br></pre></td></tr></table></figure></p><p>这种情况下，cin将不断读取，直至遇到第一个不属于浮点数的字符。也就是说，cin读取3、8、句点和5使得空格成为输入队列的下一个字符。cin通过计算发现，这四个字符对应数值38.5，因此将38.5的二进制编码(浮点格式)复制到变量x中。<br>那么char数组又如何？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> word[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; word;</span><br></pre></td></tr></table></figure></p><p>这种情况下，cin将不断读取，直到遇到空白字符。也即是，它读取3、8、句点和5。使得空格成为输入队列的下一个字符。然后，cin将这4个字符的编码存储到数组word中，并在末尾加上一个空字符。这里不需要进行任何转换。<br>最后便是另一种使用char数组的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> word[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(word, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></p><p>这种情况下，cin将不断读取直至遇上换行符(示例输入少于50个字符)。所有字符都将被存储到数组word中，并在末尾加上一个空字符。换行符被丢弃，输入队列中的下一个字符是下一行中的第一个字符。<br>我们这里讨论的I/O相当于控制台I/O，因此仅适用于文本文件。</p><h3 id="写入到文本文件"><a href="#写入到文本文件" class="headerlink" title="写入到文本文件"></a>写入到文本文件</h3><p>对于文件输入，C++使用类似于cout的东西。下面来复习一下：  </p><ul><li>必须包含头文件iostream。</li><li>头文件iostream定义了一个用于处理输出的ostream类。 </li><li>头文件iostream声明了一个名为cout的ostream变量(对象)。</li><li>必须指明名称空间std；例如，为引用元素cout和endl，必须使用编译指令using或前缀std::。</li><li>可以结合使用cout和运算符&lt;&lt;来显示各种类型的数据。  </li></ul><p>文件输出与此十分类似：  </p><ul><li>必须包含头文件fstream。</li><li>头文件fstream定义了一个用于处理输出的ofstream类。</li><li>需要声明一个或多个ofstream变量(对象)，并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。</li><li>必须指明名称空间std；例如，为引用元素ofstream，必须使用编译指令using或前缀std::。</li><li>需要将ofstream对象与文件关联起来。为此，方法之一是使用open()方法。</li><li>使用完文件后，应使用方法close()将其关闭。</li><li>可结合使用ofstream对象和运算符&lt;&lt;来输出各种类型的数据。  </li></ul><p>注意，虽然头文件iostream提供了一个预先定义好的名为cout的ostream对象，但必须声明自己的ofstream对象，为其命名，并将其与文件关联。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outFile;<span class="comment">// outFile an ofstream object</span></span><br><span class="line">ofstream fout;<span class="comment">// fout an ofstream object</span></span><br></pre></td></tr></table></figure></p><p>下面演示了如何将这种对象与特定的文件关联起来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outFile.open(<span class="string">"fish.txt"</span>);<span class="comment">// outFile used to write to the fish.txt file</span></span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; filename;<span class="comment">// user specifies a name</span></span><br><span class="line">fout.open(filename);<span class="comment">// fout used to read specified file</span></span><br></pre></td></tr></table></figure></p><p>注意，方法open()接受一个C-风格字符串作为参数，这可以是一个字面字符串，也可以是存储在数组中的字符串。<br>下面演示了如何使用这种对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> wt = <span class="number">125.8</span>;</span><br><span class="line">outFile &lt;&lt; wt;<span class="comment">// write a number to fish.txt</span></span><br><span class="line"><span class="keyword">char</span> line[<span class="number">81</span>] = <span class="string">"Objects are closer than they appear."</span>;</span><br><span class="line">fout &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// write a line of text</span></span><br></pre></td></tr></table></figure></p><p>重要的是，声明一个ofstream对象并将其同文件关联起来后，便可以像使用cout那样使用它。所有可用于cout的方法(如&lt;&lt;、endl和setf())都可用于ofstream对象(如前述示例中的outFile和fout)。<br>总之，使用文件输出的主要步骤如下：  </p><ol><li>包含头文件fstream。  </li><li>创建一个ofstream对象。  </li><li>将该ofstream对象同一个文件关联起来。  </li><li>就像使用cout那样使用该ofstream对象。  </li></ol><p>下列程序演示了这种方法。它要求用户输入信息，然后将信息显示到屏幕上，再将这些信息写入到文件中。读者可以使用文本编辑器来查看该输出文件内容。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//outfile.cpp -- writing to a file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> automobile[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">double</span> a_price;</span><br><span class="line"><span class="keyword">double</span> d_price;</span><br><span class="line"></span><br><span class="line">ofstream outFile;<span class="comment">// create object for output</span></span><br><span class="line">outFile.open(<span class="string">"carinfo.txt"</span>);<span class="comment">// associate with a file</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the make and model of automobile: "</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(automobile, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the model year: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; year;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the original asking price: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a_price;</span><br><span class="line">d_price = <span class="number">0.913</span>*a_price;</span><br><span class="line"></span><br><span class="line"><span class="comment">// display information on screen with cout</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed;</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span>.setf(ios_base::showpoint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Make and model: "</span> &lt;&lt; automobile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Year: "</span> &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Was asking $"</span> &lt;&lt; a_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Now asking $"</span> &lt;&lt; d_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now do exact same things using outFile instead of cout</span></span><br><span class="line"></span><br><span class="line">outFile &lt;&lt; fixed;</span><br><span class="line">outFile.precision(<span class="number">2</span>);</span><br><span class="line">outFile.setf(ios_base::showpoint);</span><br><span class="line">outFile &lt;&lt; <span class="string">"Make and model: "</span> &lt;&lt; automobile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"Year: "</span> &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"Was asking $"</span> &lt;&lt; a_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"Now asking $"</span> &lt;&lt; d_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">outFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该程序的最后一部分与cout部分相同，只是将cout替换为outFile而已。下面是该程序的运行情况：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/outfile.cpp输出.png" alt="输出"><br>屏幕输出使用的是cout的结果。如果我们查看源文件outfile.cpp的目录，将看到一个名为carinfo.txt的新文件，其中包含outFile生成的输出。打开文本编辑器，显示如下：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/outfile.cpp文本输出.png" alt="文本输出"><br>正如你们所见，outFile将屏幕上的内容写入到了文件carinfo.txt中。</p><h4 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h4><p>在程序中，声明一个ofstream对象后，便可以使用方法open()将该对象和特定文件关联起来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outFile;<span class="comment">// create object for output</span></span><br><span class="line">outFile.open(<span class="string">"carinfo.txt"</span>);<span class="comment">// associate with a file</span></span><br></pre></td></tr></table></figure></p><p>程序使用完该文件后，应当将其关闭：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.close();</span><br></pre></td></tr></table></figure></p><p>需要注意的是，方法close()不需要参数，这是因为outFile已经同特定的文件关联起来了。如果忘记关闭文件，程序正常终止时将自动关闭它。<br>outFile可以使用cout可使用的任何方法。它不但能够使用运算符&lt;&lt;，还可以使用各种格式化方法，如self()和precision()。这些方法只影响调用它们的对象。例如，对于不同的对象，可以提供不同的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>);<span class="comment">// use a precision of 2 for the display</span></span><br><span class="line">outFile.precision(<span class="number">4</span>);<span class="comment">// use a precision of 4 for the display</span></span><br></pre></td></tr></table></figure></p><p>需要记住的是，创建好ofstream对象后(如outFile)后，便可以像使用cout一样使用它。<br>回到open()：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.open(<span class="string">"carinfo.txt"</span>);</span><br></pre></td></tr></table></figure></p><p>在这里，运行程序之前，文件carinfo.txt并不存在，这种情况下，方法open()将新建一个名为carinfo.txt的文件。如果在此时运行该程序，则文件carinfo.txt存在，情况何如？默认情况下，open()将截断该文件，即将其长度截短到零——丢弃原有的内容，然后将新的输出加入到该文件中。之后我们将学习如何更改这种默认行为。<br><strong>警告：打开已有的文件，以接受输出时，默认将它长度截短为零，因此原来的内容将丢失。</strong><br>打开文件用于接受输入时可能失败。例如，指定的文件可能已经存在，但禁止对其进行访问。因此，细心的程序员将检查打开文件的操作是否成功，这将在下一个例子中介绍。</p><h3 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h3><p>接下来介绍文本文件输入，它是基于控制台输入的。控制台输入涉及多个方面，下面首先来进行总结：  </p><ul><li>必须包含头文件iostream。</li><li>头文件iostream定义了一个用于处理输入的istream类。</li><li>头文件iostream声明了一个名为cin的istream变量(对象)。</li><li>必须指明名称空间std；例如，为引用元素cin，必须使用编译指令using或前缀std::。</li><li>可以结合使用cin和运算符&gt;&gt;来读取各种类型的数据。</li><li>可以使用cin和get()方法来读取一个字符，使用cin和getline()来读取一行字符。</li><li>可以结合使用cin和eof()、fail()方法来判断输入是否成功。</li><li>对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。</li></ul><p>文件输出与此极其相似：</p><ul><li>必须包含头文件fstream。</li><li>头文件定义了一个用于处理输入的ifstream类。</li><li>需要声明一个或多个ifstream变量(对象)，并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。</li><li>必须指明名称空间std；例如，为引用元素ifstream必须使用编译指令using或前缀std::。</li><li>需要将ifstream对象与文件关联起来。为此，方法之一时使用open()方法。</li><li>使用完文件后，应使用close()方法将其关闭。</li><li>可结合使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据。</li><li>可以使用ifstream对象和get()方法来读取一个字符，使用ifstream对象和getline()来读取一行字符。</li><li>可以结合使用ifstream和eof()、fail()等方法来判断输入是否成功。</li><li>ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。</li></ul><p>注意，虽然头文件iostream提供了一个预先定义好的名为cin的istream对象，但必须声明自己的ifstream对象，为其命名，并将其同文件关联起来。下面演示了如何声明这种对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream inFile;<span class="comment">// inFile an ifstream object</span></span><br><span class="line">ifstream fin;<span class="comment">// fin an ifstream object</span></span><br></pre></td></tr></table></figure></p><p>下面演示了如何将这种对象与特定的文件关联起来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inFile.open(<span class="string">"bowling.txt"</span>);<span class="comment">// inFile used to read bowling.txt file</span></span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; filename;<span class="comment">// user specifies a name</span></span><br><span class="line">fin.open(filename);<span class="comment">// fin used to read specified file</span></span><br></pre></td></tr></table></figure></p><p>注意，方法open()接受一个C-风格字符串作为参数，这可以是一个字面字符串，也可以是存储在数组中的字符串。<br>下面演示了如何使用这种对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> wt;</span><br><span class="line">inFile &gt;&gt; wt;<span class="comment">// read a number from bowling.txt</span></span><br><span class="line"><span class="keyword">char</span> line[<span class="number">81</span>];</span><br><span class="line">fin.getline(line, <span class="number">81</span>);<span class="comment">// read a line of text</span></span><br></pre></td></tr></table></figure></p><p>重要的是，声明一个ifstream对象并将其同文件关联起来后，便可以像使用cin那样使用它。所有用于cin的操作和方法都可用于ifstream对象(如前述示例中的inFile和fin)。<br>如果试图打开一个不存在的文件用于输入，情况何如？这种错误将导致后面使用ifstream对象进行输入时失败。检查文件是否被成功打开的首先方法是使用方法is_open()，为此，可以使用类似于下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inFile.open(<span class="string">"bowling.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!inFile.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果文件被成功地打开，方法is_open()将返回true；因此如果文件没有被打开，表达式!inFile.is_open()的值将为true。函数exit()的原型是在头文件cstdlib中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值EXIT_FAILURE。函数exit()终止程序。下图是cstdlib对EXIT_FAILURE的定义。<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/cstdlib中对于EXIT_FAILURE的定义.png" alt="定义"><br>相对的，cstdlib中也存在参数值EXIT_SUCCESS，它的定义是：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/cstdlib中对于EXIT_SUCCESS的定义.png" alt="定义"><br>方法is_open()是C++中相对较新的内容。如果读者编译器不支持它，可以使用较老的方法good()代替。在后面的学习中会讨论，方法good()在检查可能存在的问题方面，没有is_open()那么广泛。<br>下列程序打开用户指定的文件，读取器中的数字，然后指出文件中包含多少个值以及它们的和与平均值。正确地设计输入循环至关重要。详细请看后面地“程序说明”。注意，通过使用if语句，该程序受益匪浅。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sumafile.cpp -- functions with an array argument</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;// file I/O support</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;// support for exit()</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">60</span>];</span><br><span class="line">ifstream inFile;<span class="comment">// object for handling file input</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter name of data file: "</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(filename, SIZE);</span><br><span class="line">inFile.open(filename);<span class="comment">// associate inFile with a file</span></span><br><span class="line"><span class="keyword">if</span> (!inFile.is_open())<span class="comment">// failed to open file</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not open the file "</span> &lt;&lt; filename &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Program terminating.\n"</span>;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> value;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// number of items read</span></span><br><span class="line"></span><br><span class="line">inFile &gt;&gt; value;<span class="comment">// get first value</span></span><br><span class="line"><span class="keyword">while</span> (inFile.good())<span class="comment">// while input good and not at EOF</span></span><br><span class="line">&#123;</span><br><span class="line">++count;<span class="comment">// one more item read</span></span><br><span class="line">sum += value;<span class="comment">// calculate running total</span></span><br><span class="line">inFile &gt;&gt; value;<span class="comment">// get next value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inFile.eof())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"End of file reached.\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (inFile.fail())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by data mismatch.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by unknown reason.\n"</span>;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No data processed.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Items read: "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Average: "</span> &lt;&lt; sum / count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">inFile.close();<span class="comment">// finished with the file</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要运行上述程序，首先必须创建一个包含数字的文本文件。为此，可以使用文本编辑器(如用于编写源代码的文本编辑器)。假设该文件名为scores.txt，包含的内容如下：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/scores.txt.png" alt="文本文档"><br><strong>警告：Windows文本文件的每一行都以回车字符和换行符结尾；通常情况下，C++再读取文件时将这两个字符转换为换行符，并在写入文件时执行相反的转换。有些文本编辑器(如Metroweeks Code Warrior IDE编辑器)，不会自动在最后一行末尾加上换行符。因此，如果读者使用的是这种编辑器，请在输入最后的文本后按下回车键，然后在保存文件。</strong><br>下面是该程序的运行情况：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/sumafile.cpp输出.png" alt="输出">    </p><h4 id="程序说明-1"><a href="#程序说明-1" class="headerlink" title="程序说明"></a>程序说明</h4><p>该程序没有使用硬编码文件名，而是将用户提供的文件名存储到字符数组filename中，然后将该数组用作open()的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inFile.open(filename);</span><br></pre></td></tr></table></figure></p><p>特别需要注意的是循环的正确设计。读取文件时，有几点需要检查。首先，程序读取文件时不应超过EOF。如果最后一次读取数据时遇到EOF，方法eof()将返回true。其次，程序可能遇到类型不匹配的情况。例如，上述程序期望文件中只包含数字。如果最后一次读取操作发生了类型不匹配的情况，方法fail()将返回true(如果遇到了EOF，该方法也将返回true)。最后，可能出现意外的问题还有很多，如文件受损或硬件故障。如果最后一次读取文件时发生了这样的问题，方法bad()将返回true。不要分别检查这些情况，一种更简单的方法是使用good()方法，该方法在没有发生任何错误时返回true：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (inFile.good())<span class="comment">// while input good and not at EOF</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，如果愿意，可以用其他方法来确定循环终止的真正原因：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inFile.eof())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"End of file reached.\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (inFile.fail())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by data mismatch.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by unknown reason.\n"</span>;</span><br></pre></td></tr></table></figure></p><p>这些代码紧跟在循环的后面，用于判断循环为何终止。由于eof()只能判断是否到达EOF，而fail()可用于检查EOF和类型不匹配，因此上述代码首先判断是否到达EOF。这样，如果执行到了else if测试，便可排除EOF，因此，如果fail()返回true，便可断定导致循环终止的原因是类型不匹配。<br>方法good()指出最后一次读取输入的操作是否成功，这十分重要。这意味着应该在执行读取输入操作后，立刻应用这种测试。为此，一种标准方法是，在循环之前(首次执行循环测试前)放置一条输入语句，并在循环的末尾(下次执行循环测试之前)放置另一条输入语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// standard file-reading loop design</span></span><br><span class="line">inFile &gt;&gt; value;<span class="comment">// get first value</span></span><br><span class="line"><span class="keyword">while</span> (inFile.good())<span class="comment">// while input good and not at EOF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// loop body goes here</span></span><br><span class="line">inFile &gt;&gt; value;<span class="comment">// get next value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>鉴于以下事实，可以将上述代码精简：表达式inFile &gt;&gt; value的结果为inFile，而在需要一个bool值的情况下，inFile的结果为inFile.good()，即true或false。<br>因此，可以将两条输入语句用一条用作循环测试的输入语句代替。也就是说，可以将上述循环结构替换为如下循环结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abbreviated file-reading loop design</span></span><br><span class="line"><span class="comment">// omit pre-loop input</span></span><br><span class="line"><span class="keyword">while</span> (inFile &gt;&gt; value)<span class="comment">// read and test for success</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//loop body goes here</span></span><br><span class="line"><span class="comment">// omit end-of-loop input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此种设计仍然遵循了在测试之前进行读取的规则，因为要计算表达式inFile &gt;&gt; value的值，程序首先试图将一个数据读取到value中。<br>至此，我们对文件I/O有了初步的认识。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法谜题二</title>
      <link href="/2019/04/29/%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98%E4%BA%8C/"/>
      <url>/2019/04/29/%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>这是《算法谜题》中的第4到第6题。<br><a id="more"></a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="简单谜题"><a href="#简单谜题" class="headerlink" title="简单谜题"></a>简单谜题</h3><h4 id="士兵摆渡"><a href="#士兵摆渡" class="headerlink" title="士兵摆渡"></a>士兵摆渡</h4><h5 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h5><p>25个士兵组成的小分队需要渡河，可是河宽且水深，周围也看不到桥。他们发现河岸边有一个小船，两个12岁的男孩正在上面玩耍。船很小，仅能承载两个男孩或一个士兵的重量。士兵应怎样渡河？在你用的算法中，船从一个岸边到另一个岸边来回共计几次？</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><p>考虑到船一次只能载一个士兵，那么每一次就有一个士兵驾船前去对岸，再由1个小孩驾船回来。一次可以将2个小孩运载至对岸。那么过程就很清晰了：2个男孩过河-&gt;1个男孩回来-&gt;一个士兵过河-&gt;另1个男孩驾船回来，重复至所有士兵都渡河完成。那么这样一来，船一共靠岸100次。</p><h5 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">soldiersCrossRiver</span><span class="params">(<span class="keyword">int</span> numberOfSoldiers)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!allSolidersAreCrossed())&#123;</span><br><span class="line">boat.SendPeople(boy1, boy2, there);<span class="comment">// boat.SendPeople(object1, object2, toPlace);</span></span><br><span class="line">boat.SendPeople(boy1, here);<span class="comment">// boat.SendPeople(object, toPlace)</span></span><br><span class="line">boat.SendPeople(soldier, there);</span><br><span class="line">boat.SendPeople(boy2, here);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="行列变换"><a href="#行列变换" class="headerlink" title="行列变换"></a>行列变换</h4><h5 id="题目概述-1"><a href="#题目概述-1" class="headerlink" title="题目概述"></a>题目概述</h5><!--使用<p align="left/right/center">进行居左/居右/居中操作 --><p><img src="/2019/04/29/算法谜题二/图2.1 行列变换前的数字阵列.png" alt="变换前">  </p><p></p><p align="center">图2.1 行列变换前的数字阵列<br><img src="/2019/04/29/算法谜题二/图2.1 行列变换后的数字阵列.png" alt="变换后"><br>图2.1 行列变换后的数字阵列  </p><br>怎样才能将图一中的数字阵列进行变换得到图二？要求只能进行行列变换。<p></p><h5 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h5><p>线性代数的知识告诉我们，对行列式进行行列变换不改变元素的相对位置。因此答案是不可以的。</p><h5 id="伪代码实现-1"><a href="#伪代码实现-1" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在的</span></span><br></pre></td></tr></table></figure><h4 id="数数的手指"><a href="#数数的手指" class="headerlink" title="数数的手指"></a>数数的手指</h4><h5 id="题目概述-2"><a href="#题目概述-2" class="headerlink" title="题目概述"></a>题目概述</h5><p>一个小女孩正在用左手手指数数，从1数到1000。她从拇指算作1开始数起，然后，食指为2，中指为3，无名指为4，小指为5。接下来调转方向，无名指算作6，中指为7，食指为8，大拇指为9，接下来，食指算作10，如此反复。问如果她继续按这种方式数下去，最后结束时是停在哪根手指上？</p><h5 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h5><p>我们不妨先看下前几个数字，找找规律：<br><img src="/2019/04/29/算法谜题二/数字特征.png" alt="数字特征">   </p><p></p><p align="center">前几位数字与手指的匹配规律  </p><br>具体的判断方法就不用我多说了8。当数数到1000时，对应的手指是食指。<p></p><h5 id="伪代码实现-2"><a href="#伪代码实现-2" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Finger <span class="title">getTheFinger</span><span class="params">(<span class="keyword">int</span> countNumber)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> preCaculateNum = countNumber % <span class="number">8</span>;</span><br><span class="line">Finger result;</span><br><span class="line"><span class="keyword">switch</span> (preCaculateNum)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: result.setFinger(thumb); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">0</span>: result.setFinger(foreFinger); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">7</span>: result.setFinger(middleFinger); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">6</span>: result.setFinger(ringFinger); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: result.setFinger(littleFinger); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: result.setFinger(<span class="keyword">null</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法谜题一</title>
      <link href="/2019/04/27/%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98%E4%B8%80/"/>
      <url>/2019/04/27/%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>唔，总算还是开始了算法的学习与研究了。在这里写下每天做出来的算法题吧。<br><a id="more"></a></p><h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h2><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p><h2 id="我使用的书籍——《算法谜题》"><a href="#我使用的书籍——《算法谜题》" class="headerlink" title="我使用的书籍——《算法谜题》"></a>我使用的书籍——《算法谜题》</h2><p>《算法谜题》是一本经典算法谜题的合集。书中包括了一些古已有之的谜题，数学和计算机科学有一部分知识就发源于此。 《算法谜题》可以为对算法感兴趣的广大读者提供系统丰富而实用的资料，能够帮助读者提升高阶算法思维能力。《算法谜题》适合计算机专业的高校教师和学生，想要培养和训练算法思维和计算思维的IT专业人士，以及在准备面试的应聘者和面试官阅读参考。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="简单谜题"><a href="#简单谜题" class="headerlink" title="简单谜题"></a>简单谜题</h3><h4 id="狼羊菜过河"><a href="#狼羊菜过河" class="headerlink" title="狼羊菜过河"></a>狼羊菜过河</h4><h5 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h5><p>一个人在河边，带着一匹狼、一只羊和一颗卷心菜，<br>他需要用船将这三样东西运至对岸，然而，这艘船的空间有限，只容得下他自己和另一样东西(或狼或羊或卷心菜)。<br>若他不在场看管的话，狼就会去吃羊，羊就会去吃卷心菜。此人如何才能把这三个“乘客”都送至对岸？  </p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><p>我们首先考虑第一次移动，如果移动菜或者狼，那么剩下的对象就会“冲突”，因此我们将羊作为第一次移动的目标。人再回到这边，接下来有两个选项，载菜或者载狼，首先考虑载狼吧，把狼载过去，再把羊载回来，这边再把菜带过去，然后回来接羊，任务完成。那么载菜又如何呢，把菜载过去，再回来接羊，任务也完成了。不过，第一种方案似乎要更为简洁。</p><h5 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">crossTheRiver</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isOk(there))&#123;<span class="comment">// 当对岸没有达到要求时</span></span><br><span class="line">tryMove(object);<span class="comment">// 尝试移动一个对象</span></span><br><span class="line">checkAvailable(here);<span class="comment">// 检查此边是否冲突</span></span><br><span class="line">checkAvailable(there);<span class="comment">// 检查对面是否冲突</span></span><br><span class="line"><span class="keyword">if</span>(isAvailable(here)&amp;&amp;isAvailable(there))<span class="comment">// 如果两边都可以</span></span><br><span class="line">Move(object);<span class="comment">// 移动对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 完成后返回真值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手套问题"><a href="#手套问题" class="headerlink" title="手套问题"></a>手套问题</h4><h5 id="题目概述-1"><a href="#题目概述-1" class="headerlink" title="题目概述"></a>题目概述</h5><p>抽屉中有20只手套。其中5双黑手套，3双棕色手套和2双灰手套。你只能在黑暗中挑手套，并且只有将手套挑出之后才能检查其颜色。最多要挑几次才能满足以下条件？<br>(a)至少挑出一双颜色匹配的手套。<br>(b)所有颜色的手套都至少挑出一双匹配的。</p><h5 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h5><p>(a)考虑最坏的情况：摸了10次，10双手套的一只都在手上了，那么再来一次就可以配上一双了。所以答案是11次。<br>(b)同样的，考虑极端坏的情况：把5双黑的摸齐了，3双棕色的也不放过，就差一只灰色的了，一共就是5×2+3×2+1+1+1=19次(灰色手套2只单的加上最后凑上双)</p><h5 id="伪代码实现-1"><a href="#伪代码实现-1" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鄙人才疏学浅，不会</span></span><br></pre></td></tr></table></figure><h4 id="矩形切割"><a href="#矩形切割" class="headerlink" title="矩形切割"></a>矩形切割</h4><h5 id="题目概述-2"><a href="#题目概述-2" class="headerlink" title="题目概述"></a>题目概述</h5><p>找出所有将一个矩形分成n个直角三角形的方法(n&gt;1)。并且将这种切割的方法归纳成一个算法。</p><h5 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h5><p>当n=2时，很容易考虑到对角线，一个对角线将一个矩形分为两个直角三角形。那么，当n&gt;2时，又该怎么办呢？我们不妨在直角三角形中作高线，这条高线将这个直角三角形分成了两个新的直角三角形。那么，答案就显而易见了：沿对角线切割，然后找到一个直角三角形作出高线，直到数目达到要求。</p><h5 id="伪代码实现-2"><a href="#伪代码实现-2" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seperateRectangle</span><span class="params">(<span class="keyword">int</span> triangleRequired, Rectangle rectangle)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(numOfTriangle &lt; triangleRequired)&#123;<span class="comment">// 当数目不足时进行分割</span></span><br><span class="line"><span class="keyword">if</span> (numOfTriangle == <span class="number">0</span>)&#123;<span class="comment">// 当第一次进行分割时</span></span><br><span class="line">linkDiagonal();<span class="comment">// 连接(矩形的)对角线</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Triangle triangle = <span class="keyword">new</span> findTriangle(rectangle)<span class="comment">// 找到一个所需要的直角三角形</span></span><br><span class="line">drawTriangleAltitude(triangle);<span class="comment">// 作出高线</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 学习笔记一</title>
      <link href="/2019/04/13/html5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2019/04/13/html5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>HTML5的示例网页与简要分析。<br><a id="more"></a><br>嗯，基于种种原因我开始了HTML5的学习。所用教材为《HTML5程序设计(第2版)》<br>那么首先我们进入第一个章节——关于HTML5。  </p><h1 id="HTML5的新功能"><a href="#HTML5的新功能" class="headerlink" title="HTML5的新功能"></a>HTML5的新功能</h1><h2 id="新的DOCTYPE和字符集"><a href="#新的DOCTYPE和字符集" class="headerlink" title="新的DOCTYPE和字符集"></a>新的DOCTYPE和字符集</h2><p>下面是一段HTML4 DOCTYPE代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"</span></span><br><span class="line"><span class="meta">"http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个似乎有点长，难以记忆，我们往往只能使用复制粘贴的方式来解决这个问题，同时也存在复制错误的可能性。<br>对于<br>这个问题，HTML5给出了漂亮的解决方案：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在的DOCTYPE好记多了。和它一样，字符集的声明也简化了许多。下面是过去的代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在成了：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当然，使用HTML5的DOCTYPE会触发浏览器以标准兼容模式显示页面。众所周知，Web页面有多种显示模式，如怪异模式(Quirks)、近标准模式(Almost Standards)以及标准模式(Standards)，其中标准模式也称作非怪异模式(no-quirks)。浏览器根据DOCTYPE识别该使用哪种模式，并且根据它来确定使用什么规则验证页面。怪异模式下，浏览器尽量不中断显示，即使没有完全通过验证也会显示出来。HTML5引入了新的标记元素和其他机制，因此如果坚持使用废弃的元素，页面将通不过验证。</p><h2 id="新元素和旧元素"><a href="#新元素和旧元素" class="headerlink" title="新元素和旧元素"></a>新元素和旧元素</h2><p>HTML5引入了很多新元素，根据类型不同，分为了7大类，如下表所示：<br><!--表格类内容牺牲了排版，因为hexo next有bug，会留下大段空白--></p><p><table><thead><tr><th>内容类型</th><th>描述</th></tr></thead><tbody><tr><td>内嵌</td><td>向文档中添加其他类型的内容，例如audio、video、canvas和iframe等</td></tr><tr><td>流</td><td>在文档和应用的body中使用的元素，例如form、h1和small等</td></tr><tr><td>标题</td><td>段落标题，例如h1、h2和hgroup等</td></tr><tr><td>交互</td><td>和用户交互的内容，例如音频和视频控件、button和textarea等</td></tr><tr><td>元数据</td><td>通常出现在页面的head中，设置页面其他部分的表现和行为，例如script、style和title等</td></tr><tr><td>短语</td><td>文本和文本标记元素，例如mark、kbd、sub和sup等</td></tr><tr><td>片段</td><td>用于定义文档中片段的元素，例如article、aside和title等</td></tr></tbody></table><br>上述所有类型的元素都可以通过CSS来设定样式。此外，其中一些元素，如canvas、audio和video，在使用时往往需要其他API来配合，以实现细粒度控制，但也可以直接使用。这将在后续进行学习。</p><h2 id="语义化标记"><a href="#语义化标记" class="headerlink" title="语义化标记"></a>语义化标记</h2><p>Google分析了上百万的页面，发现了DIV标签的通用ID名称重复量很大。所以引入了一组新的片段类元素进入HTML5，在目前主流浏览器中已经可以使用了，如下表：<br><!--排版原因同上--></p><p><table><thead><tr><th>元素名</th><th>描述</th></tr></thead><tbody><tr><td>header</td><td>标记头部区域的内容(用于整个页面或页面中的一块区域)</td></tr><tr><td>footer</td><td>标记脚部区域的内容(用于整个页面或页面中的一块区域)</td></tr><tr><td>section</td><td>Web页面中的一块区域</td></tr><tr><td>article</td><td>独立的文章内容</td></tr><tr><td>aside</td><td>相关内容或者引文</td></tr><tr><td>nav</td><td>导航类辅助内容</td></tr></tbody></table><br>同样，上述所有元素也可以用CSS设定样式。<br>下面是一个HTML5页面的概貌，其中使用了新的DOCTYPE、字符集和语义化标记元素——新的片段类元素。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- test.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"test.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Subtitle<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>HTML5 Rocks!<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Nav<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com"</span>&gt;</span>link 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com"</span>&gt;</span>link 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com"</span>&gt;</span>link 3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Article Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor HTML5 nunc aut nunquam sit amet, consectetur adiplscing</span><br><span class="line">elit.Vivamus at</span><br><span class="line">est eros, vel fringilla urna.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Article Footer<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Article Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>HTML5:"Lorem ipsum dolor nunc aut nunquam sit amet, consectetur adipiscing</span><br><span class="line">elit. Vivamus at est eros, vel fringilla urna. Pellentesque odio</span><br><span class="line">rhoncus<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Article Footer<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Aside<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>HTMP5:"Lorem ipsum dolor nunc qut nunquam sit amet, consectetur adipiscing</span><br><span class="line">elit. Vivamus at est eros, vel fringilla urna. Pellentesque odio</span><br><span class="line">rhoncus<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Footer<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>没有样式的页面看起来很逊。下面是一些可以用来设置内容样式的CSS代码。需要注意的是，它使用了CSS3的一些新特性，例如圆角(border-radius)和旋转变换(transform:rotate())。CSS3同HTML5一样正在开发，为了便于浏览器逐步支持，也采用了模块化的发布子规范，例如变换(transformation)、动画(animation)和过渡(transition)分别对应不同的子规范。<br>CSS3规范可能会变动，功能也处于实验期，为了避免命名空间冲突，功能都会加上浏览器厂商的前缀。要显示圆角、渐变(gradients)、阴影(shadows)和变形(transformations)的话，需要在声明的部分加上前缀：-moz-(Mozilla浏览器)、o-(Opear浏览器)和-webkit-(Safari和Chrome等基于WebKit核心的浏览器)。<br>下面是对应上面HTML5页面的CSS文件的源码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#CCCCCC</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Geneva, Arial, Helvetica, sans-serif;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">900px</span>;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">#FFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">72px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h4</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">-webkit-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">20px</span> <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">    <span class="attribute">-moz-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">20px</span> <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">3px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#888</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-webkit-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">20px</span> <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(-10deg);</span><br><span class="line">    <span class="attribute">-moz-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">20px</span> <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(-10deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">footer</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* links */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果就请读者自行验证。</p>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记四</title>
      <link href="/2019/04/10/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
      <url>/2019/04/10/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>关于循环的一些内容<br><a id="more"></a></p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="编写延时循环"><a href="#编写延时循环" class="headerlink" title="编写延时循环"></a>编写延时循环</h3><p>有时候，我们需要让程序等待一段时间。在之前的C语言课程设计之中，使用了Sleep(int milliseconds)函数来处理这个事情。while循环也可用于这种目的，一种早期的用于个人计算机的技术是，让其进行计数，以等待一段时间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> wait = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (wait &lt; <span class="number">10000</span>)</span><br><span class="line">wait++;<span class="comment">// counting silently</span></span><br></pre></td></tr></table></figure></p><p>但潜在的问题是这受到计算机处理器处理速度的影响。更好的方法是用系统时钟来完成此项工作。<br>ANSI C和C++库中有一个函数有助于完成这样一项工作。这个函数就是clock()，返回程序开始执行后所用的系统时间。这有几个问题：首先，返回的时间单位不一定为秒；其次，返回值的类型与系统有关，可能是long也可能是unsigned long或其他。<br>头文件ctime(较早的实现中使用time.h)提供了解决方案。首先，它定义了一个符号常量——CLOCKS_PER_SEC，该常量等于每秒钟包含的系统时间单位数。因此将系统时间除以这个常量可以得到秒数，或是将秒数诚意CLOCK_PER_SEC就可以得到以系统时间单位为单位的时间。其次，ctime将clock_t作为clock()返回类型的别名(将会在后面提起)，这意味着可以将变量声明为clock_t类型，编译器将进行转换以适应系统。<br>下列程序演示了使用clock()和头文件ctime创建延时循环：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// waiting.cpp -- using clock() in a time-delay loop</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;// describes clock() function, clock_t type</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the delay time, in seconds: "</span>;</span><br><span class="line"><span class="keyword">float</span> secs;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; secs;</span><br><span class="line"><span class="keyword">clock_t</span> delay = secs * CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"starting\a\n"</span>;</span><br><span class="line"><span class="keyword">clock_t</span> start = clock();</span><br><span class="line"><span class="keyword">while</span> (clock() - start &lt; delay);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"done \a\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该程序以系统时间为单位计算延迟时间，避免了在每轮循环中将系统时间转换为秒。  </p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>C++为类型建立别名的方式有两种。一种是使用预处理器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BYTE char <span class="comment">// preprocessor replaces BYTE with char</span></span></span><br></pre></td></tr></table></figure></p><p>这样，预处理器将在编译程序时用char替换所有的BYTE，从而使BYTE成为char的别名。<br>第二种方法是使用C++(和C)的关键字typedef来创建别名。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> type;</span><br></pre></td></tr></table></figure></p><p>下面是通用格式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> typeName aliasName;</span><br></pre></td></tr></table></figure></p><p>换句话说，如果要将aliasName作为某种类型的别名，可以声明aliasName，如同将aliasName声明为这种类型的变量那样，然后在声明的前面加上关键字typedef。例如，要让byte_pointer成为char指针的别名，可将byte_pointer声明为char指针，然后在前面加上typedef：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * byte_pointer;<span class="comment">// pointer to char type</span></span><br></pre></td></tr></table></figure></p><p>也可以使用#define，不过声明一系列变量时，这种方法不适用。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOAT_POINTER float *</span></span><br><span class="line">FLOAT_POINTER pa, pb;</span><br></pre></td></tr></table></figure></p><p>预处理器将声明转换为这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> * pa, pb;<span class="comment">// pa a pointer to float, pb just a float</span></span><br></pre></td></tr></table></figure></p><p>typedef方法不会有这样的问题。它能够处理更复杂的类型别名。<br><strong>注意，typedef不会创建新类型，</strong>而只是为已有的类型创建一个新名称。  </p><h3 id="基于范围的for循环-C-11"><a href="#基于范围的for循环-C-11" class="headerlink" title="基于范围的for循环(C++11)"></a>基于范围的for循环(C++11)</h3><p>C++11新增了一种循环：基于范围(range-based)的for循环。这简化了一种常见的循环任务：对数组(或容器类，如vector和array)的每个元素执行相同的操作，如下例所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">4.99</span>, <span class="number">10.99</span>, <span class="number">6.87</span>, <span class="number">7.99</span>, <span class="number">8.49</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> x : prices)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>其中，x最初表示数组prices的第一个元素。显示第一个元素后不断执行循环，而x依次表示数组的其他元素。<br>要修改数组的元素，需要使用不同的循环变量语法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> &amp;x : prices)</span><br><span class="line">x = x * <span class="number">0.80</span>;</span><br></pre></td></tr></table></figure></p><p>符号&amp;表明x是一个引用变量，这个将在后面学习。就这里而言，这种声明可以修改数组的内容，而第一种语法不行。<br>还可以结合使用基于范围的for循环和初始化列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>&#125;)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p><p>然而，这种循环主要用于后面的各种模板容器类。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记三</title>
      <link href="/2019/03/31/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
      <url>/2019/03/31/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>关于类vector和array的一些内容<br><a id="more"></a></p><h2 id="数组的替代品"><a href="#数组的替代品" class="headerlink" title="数组的替代品"></a>数组的替代品</h2><h3 id="模板类vector"><a href="#模板类vector" class="headerlink" title="模板类vector"></a>模板类vector</h3><p>模板类vector类似于string类，也是一种动态数组。可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的。<br>这里不深入探讨模板类意味着什么，只介绍一些基本的实用知识。首先，要使用vector对象，必须包含头文件vector。其次，vector包含在名称空间std中，因此可以使用using编译指令、using声明或std::vector。第三，模板使用不同的语法来指出它储存的数据类型。第四，vector类使用不同的语法来制定元素数。下面是一些示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;<span class="comment">// create a zero-size array of int</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd(n);<span class="comment">// create an array of n doubles</span></span><br></pre></td></tr></table></figure></p><p>其中，vi是一个vector<int>对象。由于vector对象在插入或添加时自动调整长度，因此可以将vi的初始长度设置为零。但要调整长度，需要使用vector包中的各种方法。<br>一般而言，下面的声明创建一个名为vt的vector对象，它可存储n_elem个类型为typeName的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;typeName&gt; vt(n_elem);</span><br></pre></td></tr></table></figure></int></p><p>其中参数n_elem可以是整形常量，也可以是整形变量。</p><h3 id="模板类array（C-11）"><a href="#模板类array（C-11）" class="headerlink" title="模板类array（C++11）"></a>模板类array（C++11）</h3><p>vector类的功能比数组强大，但付出的代价是效率稍低。如果需要的是长度固定的数组，使用数组时更佳的选择，但代价是不那么方便和安全。有鉴于此，C++11新增了模板类array，它也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。要创建array对象，需要包含头文件array。array对象的创建语法与vector稍有不同：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; ai;<span class="comment">// create array object of 5 ints</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; ad = &#123;<span class="number">1.2</span>, <span class="number">2.1</span>, <span class="number">3.43</span>, <span class="number">4.3</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>推而广之，下面的声明创建一个名为arr的array对象，它包含n_elem个类型为typeName的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;typeName, n_elem&gt; arr;</span><br></pre></td></tr></table></figure></p><p>与创建vector对象不同的是，n_elem不能是变量。<br>在C++11中，可将列表初始化用于vector和array对象，但在C++98中，不能对vector对象这样做。</p><h3 id="比较数组、vector对象和array对象"><a href="#比较数组、vector对象和array对象" class="headerlink" title="比较数组、vector对象和array对象"></a>比较数组、vector对象和array对象</h3><p>要了解数组、vector对象和array对象的相似和不同之处，最简单的方式可能是看一个使用它们的示例，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choice.cpp -- array variations</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;// STL C++98</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;// C++11</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// C, original C++</span></span><br><span class="line"><span class="keyword">double</span> a1[<span class="number">4</span>] = &#123;<span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">3.6</span>, <span class="number">4.8</span>&#125;;</span><br><span class="line"><span class="comment">// C++98 STL</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; a2[<span class="number">4</span>];<span class="comment">// create vector with 4 elements</span></span><br><span class="line"><span class="comment">// no simple way to initialize in C98</span></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">1.0</span>/<span class="number">3.0</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">1.0</span>/<span class="number">5.0</span>;</span><br><span class="line">a2[<span class="number">2</span>] = <span class="number">1.0</span>/<span class="number">7.0</span>;</span><br><span class="line">a2[<span class="number">3</span>] = <span class="number">1.0</span>/<span class="number">9.0</span>;</span><br><span class="line"><span class="comment">// C++11 -- create and initialize array object</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; a3 = &#123;<span class="number">3.14</span>, <span class="number">2.72</span>, <span class="number">1.62</span>, <span class="number">1.41</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; a4;</span><br><span class="line">a4 = a3;<span class="comment">// valid for array objects of same size</span></span><br><span class="line"><span class="comment">// use array notation</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a1[2]: "</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a1[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a2[2]: "</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a2[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a3[2]: "</span> &lt;&lt; a3[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a3[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a4[2]: "</span> &lt;&lt; a4[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a4[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// misdeed</span></span><br><span class="line">a1[<span class="number">-2</span>] = <span class="number">20.2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a1[-2]: "</span> &lt;&lt; a1[<span class="number">-2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a1[<span class="number">-2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a3[2]: "</span> &lt;&lt; a3[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a3[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a4[2]: "</span> &lt;&lt; a4[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a4[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是该程序的输出示例：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a1</span><span class="selector-attr">[2]</span>: 3<span class="selector-class">.6</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28cce8</span></span><br><span class="line"><span class="selector-tag">a2</span><span class="selector-attr">[2]</span>: 0<span class="selector-class">.142857</span> <span class="selector-tag">at</span> 0<span class="selector-tag">xca0328</span></span><br><span class="line"><span class="selector-tag">a3</span><span class="selector-attr">[2]</span>: 1<span class="selector-class">.62</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28ccc8</span></span><br><span class="line"><span class="selector-tag">a4</span><span class="selector-attr">[2]</span>: 1<span class="selector-class">.62</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28cca8</span></span><br><span class="line"><span class="selector-tag">a1</span><span class="selector-attr">[-2]</span>: 20<span class="selector-class">.2</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28ccc8</span></span><br><span class="line"><span class="selector-tag">a3</span><span class="selector-attr">[2]</span>: 20<span class="selector-class">.2</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28ccc8</span></span><br><span class="line"><span class="selector-tag">a4</span><span class="selector-attr">[2]</span>: 1<span class="selector-class">.62</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28cca8</span></span><br></pre></td></tr></table></figure></p><h4 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h4><p>首先，注意到不论是数组、vector对象还是array对象，都可使用标准数组表示法来访问各个元素。其次，从地址可知，array对象和数组储存在相同的内存区域（即栈）中，而vector对象存储在另一个区域（自由存储区或堆中）。第三，注意到可以将一个array对象赋给另一个array对象；而对于数组，必须逐元素复制数据。<br>接下来，下面一行代码需要特别注意：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1[<span class="number">-2</span>] = <span class="number">20.2</span>;</span><br></pre></td></tr></table></figure></p><p>索引-2是什么意思呢？它将会被转换为如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(a1<span class="number">-2</span>) = <span class="number">20.2</span>;</span><br></pre></td></tr></table></figure></p><p>其含义如下：找到a1指向的地方，向前移两个double元素，并将20.2存储到目的地。也就是说，将信息存储到数组的外面。与C语言一样，C++也不检查这种超界错误。在这个示例中，这个位置位于array对象a3中。其他编辑器可能将20.2放在a4中，甚至做出更糟糕的选择。这表明数组的行为是不安全的。<br>vector和array对象能够禁止这种行为吗？答案取决于程序员自身，也就是说，仍可编写不安全的代码，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a2[<span class="number">-2</span>] = <span class="number">.5</span><span class="comment">// still allowed</span></span><br><span class="line">a3[<span class="number">200</span>] = <span class="number">1.4</span>;</span><br></pre></td></tr></table></figure></p><p>然而，也有其他的选择。一种是使用成员函数at()。就像使用cin对象的成员函数getline()一样，也可以使用vector和array对象的成员函数at()：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.at(<span class="number">1</span>) = <span class="number">2.3</span>;<span class="comment">// assign 2.3 to a2[1]</span></span><br></pre></td></tr></table></figure></p><p>中括号表示法和成员函数at()的差别在于，使用at()时，将在运行期间捕获非法索引，而程序默认将中断。这种额外检查的代价时运行时间更长，这就是C++允许使用任何一种表示法的原因所在。另外，这些类还能够降低意外超界错误的概率。例如，他们包含成员函数begin()和end()，让程序员能够确定边界，以免无意间超界，这将在后面学习。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记二</title>
      <link href="/2019/03/22/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2019/03/22/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>关于复合类型的一些内容<br><a id="more"></a></p><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>和C语言类似，C++中也可以创建数组。数组声明应指出以下3点：<br>·储存在每个元素中的值的类型;<br>·数组名;<br>·数组中的元素数;<br>和C语言类似，声明数组的通用格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize];</span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="keyword">short</span> months[<span class="number">12</span>];</span><br></pre></td></tr></table></figure></p><p>和C语言一致，数组从0开始编号。例如，months[0]是months数组的第一个元素。可以通过索引来标示和访问各个元素。</p><h4 id="有效下标值"><a href="#有效下标值" class="headerlink" title="有效下标值"></a>有效下标值</h4><p>编译器不会检查使用的下标是否有效。在程序运行后，可能会引发问题。所以必须确保程序只使用有效的下标值。</p><h4 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h4><p>只有定义数组时才能使用初始化，此后就不能使用了，也不能进行数组间的赋值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cards[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;<span class="comment">// okay</span></span><br><span class="line"><span class="keyword">int</span> hand[<span class="number">4</span>];<span class="comment">// okay</span></span><br><span class="line">hand[<span class="number">4</span>] = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;<span class="comment">// not allowed</span></span><br><span class="line">hand = cards;<span class="comment">// not allowed</span></span><br></pre></td></tr></table></figure></p><p>如果初始化时方括号内为空，则编译器将计算元素个数。</p><h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><p>ISO/ANSI C++98标准通过添加string类扩展C++库，因此现在可以用string类型的变量(C++称之为对象)而非字符数组来存储字符串。这使用起来比数组简单。<br>要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此也需要使用using编译指令，或是std::string来引用。string类定义隐藏了字符串数组性质，因此可以像处理普通变量一样处理字符串。</p><h4 id="赋值、拼接、附加"><a href="#赋值、拼接、附加" class="headerlink" title="赋值、拼接、附加"></a>赋值、拼接、附加</h4><p>参看如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> charr1[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> charr2[<span class="number">20</span>] = <span class="string">"jaguar"</span>;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"panther"</span>;</span><br><span class="line">charr1 = charr2;<span class="comment">// INVALID</span></span><br><span class="line">str1 = str2;<span class="comment">// VALID</span></span><br></pre></td></tr></table></figure></p><p>string类简化了字符串的合并操作。在C语言中使用strcat(str1,str2)函数来进行拼接，且有诸多注意事项，但是string类则可以使用运算符+将两个string对象合并起来，也可以使用运算符+=将字符串附加到string对象的末尾。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str3;</span><br><span class="line">str3 = str1 + str2;<span class="comment">// assign str3 to the joined strings</span></span><br><span class="line">str1 += str2;<span class="comment">// add str2 to the end of str1</span></span><br></pre></td></tr></table></figure></p><p>当然，C++中也可以使用C语言库中的函数来完成这些任务。头文件cstring(以前为string.h)中提供了这些函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(charr1, charr2);<span class="comment">// copy charr2 to charr1</span></span><br><span class="line"><span class="built_in">strcat</span>(charr1, charr2);<span class="comment">// append contents of charr2 to charr1</span></span><br></pre></td></tr></table></figure></p><p>当然，在VS2017的编译环境中，会采用更安全的strcpy_s，strcat_s函数。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>和C语言相同，C++也提供结构体，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span>// <span class="title">structure</span> <span class="title">declaration</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">float</span> volume;</span><br><span class="line"><span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外，还有共用体(union，有时也叫做联合)、枚举(enum)等结构，在此便不赘述。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>熟悉C语言的都对指针有一定了解，我们在此便略过基础的知识。  </p><h4 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h4><p>C语言中我们使用malloc()来分配内存，而在C++中，可以使用new运算符来进行。<br>下面来试试这种新技术，在运行阶段将一个int值分配未命名内存，并使用指针来进行访问。程序员需要告诉new，需要为哪种数据类型分配内存;new将找到一个正确的内存块，并返回该内存块的地址。程序员的责任是将其赋给一个指针，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pn = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure></p><p>new int告诉程序，需要适合储存int的内存。new运算符根据类型来确定需要多少字节的内存，它找到这样的内存并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针。现在，pn是地址，而*pn是春促在那里的值。将其与将变量的地址赋给指针进行比较：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> higgens;</span><br><span class="line"><span class="keyword">int</span> * pt = &amp;higgens;</span><br></pre></td></tr></table></figure></p><p>在这两种情况下，都是将一个int变量地址赋给了指针。在第二种情况下，可以用名称higgens来访问该int，在第一种情况下，只能通过该指针进行访问。这便引出了一个问题：pn指向的内存没有名称，如何称呼它呢？我们说pn指向一个数据对象(不是“面向对象编程”的对象，而是一样东西)，术语“数据对象”比“变量”更为通用，它指的是为数据项分配的内存块。因此，变量也是数据对象，而pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。<br>为一个数据对象(可以是结构，也可以是基本类型)获得并制定分配内存的通用格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointer_name = <span class="keyword">new</span> typeName;</span><br></pre></td></tr></table></figure></p><p>需要在两个地方制定数据类型。</p><h4 id="使用delete来释放内存"><a href="#使用delete来释放内存" class="headerlink" title="使用delete来释放内存"></a>使用delete来释放内存</h4><p>在C语言中，一定会提到的便是malloc()之后，一定要有一个free()。这是为了避免程序将内存耗尽。C++中，使用delete运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">// allocate memory with new</span></span><br><span class="line">...<span class="comment">// use the memory</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// free memory with delete when done</span></span><br></pre></td></tr></table></figure></p><p><strong>警告：只能使用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的</strong><br><strong>不要尝试释放已经释放的内存块，这样做的结果将会是不确定的。另外，不能使用delete来释放声明变量所获得的内存</strong><br>值得注意的是，使用delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">// allocate memory</span></span><br><span class="line"><span class="keyword">int</span> * pq = ps;<span class="comment">// set second pointer to same block</span></span><br><span class="line"><span class="keyword">delete</span> pq;<span class="comment">// delete with second pointer</span></span><br></pre></td></tr></table></figure></p><p>一般来说，不要创建两个指向同一个内存块的指针。因为这将增加错误删除同一个内存块两次的可能性。不过，在之后的学习中，将会学习到，对于返回指针的函数，使用另一个指针确实有道理。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记一</title>
      <link href="/2019/03/21/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2019/03/21/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>从零开始接触C++<br><a id="more"></a><br>在经历了种种困难(其实并没有太多)之后，我开了这篇博客，在此记录我从头开始学习C++的历程。参考教材：《C++ Primer Plus (第六版) 中文版》<br>目录按照教材的目录记录  </p><h2 id="第1章-预备知识"><a href="#第1章-预备知识" class="headerlink" title="第1章 预备知识"></a>第1章 预备知识</h2><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>·C语言和C++的发展历史和基本原理。<br>·过程性编程和面向对象编程。<br>·C++是如何在C语言的基础上添加面向对象概念的。<br>·C++是如何在C语言的基础上添加泛型编程概念的。<br>·编程语言标准。<br>·创建程序的技巧。<br>本章内容请在书上阅读，这里不再赘述，以下是大纲。</p><h4 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h4><h4 id="C-简史"><a href="#C-简史" class="headerlink" title="C++简史"></a>C++简史</h4><p>1.2.1 C语言<br>1.2.2 C语言编程原理<br>1.2.3 面向对象编程<br>1.2.4 C++和泛型编程<br>1.2.5 C++的起源  </p><h4 id="可移植性和标准"><a href="#可移植性和标准" class="headerlink" title="可移植性和标准"></a>可移植性和标准</h4><p>1.3.1 C++的发展<br>1.3.2 本书遵循的C++标准</p><h4 id="程序创建的技巧"><a href="#程序创建的技巧" class="headerlink" title="程序创建的技巧"></a>程序创建的技巧</h4><p>1.4.1 创建源代码文件<br>1.4.2 编译和链接  </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h2 id="第2章-开始学习C"><a href="#第2章-开始学习C" class="headerlink" title="第2章 开始学习C++"></a>第2章 开始学习C++</h2><h3 id="大纲-1"><a href="#大纲-1" class="headerlink" title="大纲"></a>大纲</h3><p>·创建C++程序。<br>·C++程序的一般格式。<br>·#include编译指令。<br>·main()函数。<br>·使用cout对象进行输出。<br>·在C++程序中加入注释。<br>·何时以及如何使用endl。<br>·声明和使用变量。<br>·使用cin对象进行输入。<br>·定义和使用简单函数。  </p><h3 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h3><p>下面是教材中的一个cpp程序的源代码，我们从这个程序开始逐步理清楚。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myfirst.cpp -- displays a message  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;// a PREPROCESSOR directive</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">// function header</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// start of function body</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">// make definitions visible</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Come up and C++ me some time."</span>;<span class="comment">// message</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// start a new line</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"You won't regret it!"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// more output</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// terminate main()</span></span><br><span class="line">&#125;<span class="comment">// end of function body</span></span><br></pre></td></tr></table></figure></p><p>从某种意义上来讲，C++和C语言有很大的相似之处，因此我们直接将略过和C语言相似的部分。  </p><h4 id="头文件名"><a href="#头文件名" class="headerlink" title="头文件名"></a>头文件名</h4><p>第一行代码是#include <iostream> ，和C语言类似，像iostream这样的文件叫做包含文件(include file)——由于被包含在其他的文件中，也称作头文件(header file)。C语言的头文件一般使用h扩展名，但C++却没有扩展名。有些C头文件被转换为C++头文件，这些文件在文件名称上加上前缀c，例如C++版本的math.h则是cmath。对于纯粹的C++头文件来讲，去掉h后的头文件还可以包含名称空间。</iostream></p><h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h4><p>注意到和C语言不同的是那一句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure></p><p>这叫做using编译指令，在后面会进行深度的学习，现在仅仅只作了解。<br>名称空间支持是一项C++特性，旨在编写大型程序时以及将多个厂商现有代码组合起来更加容易，它也有助于组织程序。一个潜在的问题是，如果使用两个封装好产品，而它们都有一个叫做tietie()的函数，那么编译器将不知道是使用哪一个tietie()。名称空间使得厂商可以将其产品封装在一个叫做名称空间的单元中，这样便能用其来指出想要使用哪个厂商的产品。因此，Meaqua Industries可以将其定义放到一个叫做Meaqua的名称空间中。如此一来，其tietie()函数的全程就是Meaqua::tietie();同样，HimeHina公司的tietie()版本可以表示为HimeHina::tietie()。这样，程序就能使用名称空间来区分不同的版本了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Meaqua::tietie(<span class="string">"Meaquaraft"</span>);<span class="comment">// use Meaqua namespace version</span></span><br><span class="line">HimeHina::tietie(<span class="string">"Yuki"</span>);<span class="comment">// use HimeHina namespace version</span></span><br></pre></td></tr></table></figure></p><p>因此来讲，上面的iostream定义的输出的cout变量其实是std::cout，endl实际上是std::endl。因此也可以省略using，以下述方式编码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Come up and C++ me some time."</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>然而，多数用户并不喜欢将引入名称空间之前的代码(使用iostream.h和cout)转换为名称空间代码(使用iostream和std::cout)，除非他们可以毫不费力地完成这种转换。于是，using指令便应运而生了。下面的代码表示可以使用std名称空间定义的名称，而不必使用std::前缀：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure></p><p>这个using编译指令使得std名称空间中的所有名称均可用。这是一种偷懒的做法，在大型项目中会有潜在的问题。更好的方法是，只使得需要的名称可用，这也可以通过using实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;<span class="comment">// make cout available</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// make endl available</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;<span class="comment">// make cin available</span></span><br><span class="line"><span class="keyword">using</span> Meaqua::tietie;<span class="comment">// make tietie available</span></span><br></pre></td></tr></table></figure></p><h4 id="关于cout"><a href="#关于cout" class="headerlink" title="关于cout"></a>关于cout</h4><p>注意到myfirst.cpp中的以下语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Come up and C++ me some time."</span>;</span><br></pre></td></tr></table></figure></p><p>双引号中是要打印的消息。C++中将其称作字符串。&lt;&lt;符号表示将这个字符串发送给cout;该符号指出了信息流动的路径。那么什么是cout？它是一个预定义的对象，知道如何显示字符串、数字和单个字符等。<br>cout有一个简单的接口，如果string是一个字符串，则下面的代码将显示该字符串：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure></p><p>和C语言中的printf()有些不同，与其将cout显示了一条字符串，倒不如说是将字符串插入到输出流(从C++概念上来看，输出是一个流，即从程序流出的一系列字符)中。cout对象表示这种流，其属性在iostream中定义。cout的对象属性中包含有一个插入运算符(&lt;&lt;)，它可以将右侧信息插入到流中。  </p><h5 id="初识运算符重载"><a href="#初识运算符重载" class="headerlink" title="初识运算符重载"></a>初识运算符重载</h5><p>注意到插入运算符和按位左移运算符(在C语言中进行位运算时执行向左移位操作的符号)似乎是有极大的相似性，这是一个运算符重载的例子，通过重载，同一个运算符将有不同的含义。编译器通过上下文来确定运算符的含义。在C语言中，也有这种例子，例如&amp;符号，既可以表示地址运算符，也可以表示按位与运算符。*即表示乘法，也表示指针的解引用。C++扩展了运算符重载的概念，允许用户定义的类型(类)重新定义运算符的含义。</p><h5 id="cout和printf"><a href="#cout和printf" class="headerlink" title="cout和printf()"></a>cout和printf()</h5><p>和printf()相比，cout设计更加灵活、好用，并且它是可扩展的(extensible)。也就是说，可以重新定义&lt;&lt;运算符，使得cout可以识别并显示开发的新数据类型。若是喜欢printf()提供的细致控制功能，可以使用更高级的cout来获得相同效果，这将在之后的学习中提到。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2019/03/21/Hello-Hexo/"/>
      <url>/2019/03/21/Hello-Hexo/</url>
      
        <content type="html"><![CDATA[<p>使用Hexo,是一件非常简单的事。测试文本</p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/21/hello-world/"/>
      <url>/2019/03/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
