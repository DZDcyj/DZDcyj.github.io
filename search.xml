<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ Primer Plus 学习笔记七</title>
      <link href="/2019/05/30/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/"/>
      <url>/2019/05/30/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<p>关于内联函数和引用变量的一些内容<br><a id="more"></a></p><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><h3 id="什么是内联函数？"><a href="#什么是内联函数？" class="headerlink" title="什么是内联函数？"></a>什么是内联函数？</h3><p>内联函数是C++为提高程序运行速度所做的一项改进，常规函数和内联函数的主要区别不在于编写方式。而在于编译器如何将它们组合到程序中。  </p><h3 id="程序的运行过程"><a href="#程序的运行过程" class="headerlink" title="程序的运行过程"></a>程序的运行过程</h3><p>编译过程的最终产物是可执行程序——由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时(例如循环/分支语句)，将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址(函数的地址)，并在函数结束后返回。下面更详细地介绍这一过程。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数复制到堆栈(为此保留的内存块)，跳到标记函数起点的内存单元，执行函数代码(也许还需将返回值放入到寄存器中)，然后跳回到地址被保存的指令处(这与阅读文章时停下来看脚注，并在阅读完脚注后返回以前阅读的地方类似)。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。  </p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替代函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。<br>应有选择地使用内联函数。如果执行函数代码地时间比处理函数调用机制的时间长，则节省的时间将只占整个过程中很小的一部分。如果代码执行时间很短，那么内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非其经常被调用。<br>要使用这项特性，必须采取下述措施之一：</p><ul><li>在函数声明前加上关键字inline；</li><li>在函数定义前加上关键字inline。</li></ul><p>通常的做法是省略原型，将整个定义(即函数头和所有函数代码)放在本应提供原型的地方。<br>当然，内联函数只是对编译器的一种建议，编译器完全可以忽略你的建议。如果提供的函数过大或是调用了自己(内联函数不能递归)，编译器可能不会将其作为内联函数。<br>下面是一个实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline.cpp -- using an inline function</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// an inline function definition</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> a, b;</span><br><span class="line"><span class="keyword">double</span> c = <span class="number">13.0</span>;</span><br><span class="line"></span><br><span class="line">a = square(<span class="number">5.0</span>);</span><br><span class="line">b = square(<span class="number">4.5</span> + <span class="number">7.5</span>);<span class="comment">// can pass expressions</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", c squared = "</span> &lt;&lt; square(c++) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Now c = "</span> &lt;&lt; c &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它通过内联函数square()(计算参数的平方)演示了内联技术。注意到整个函数定义都放在一行中，但不一定非要这样做。然而，如果函数定义占用多行(假定没有使用冗长的标识符)，则将其作为内联函数就不大合适。<br>下面是该程序的输出：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">25</span>, b = <span class="number">144</span></span><br><span class="line">c = <span class="number">13</span>, c squared = <span class="number">169</span></span><br><span class="line">Now c = <span class="number">14</span></span><br></pre></td></tr></table></figure></p><p>输出表明，内联函数与常规函数一样，也是按值来传递参数的。如果参数为表达式，如上面的4.5+7.5，则函数将传递表达式的值(这里为12)。这使得C++的内联功能远远胜过C语言的宏定义。<br>尽管函数没有提供独立原型，但C++原型特性仍在起作用。这是因为在函数首次使用前出现的整个函数定义充当了原型。这意味着可以给square()传递int或long值，将值传递给函数前，程序自动将这个值强制转换为double类型。</p><h4 id="内联与宏"><a href="#内联与宏" class="headerlink" title="内联与宏"></a>内联与宏</h4><p>inline工具是C++新增的特性。C语言使用预处理器语句#define来提供宏——内敛代码的原始实现。例如，下面是一个计算平方的宏：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br></pre></td></tr></table></figure></p><p>这并不是通过传递参数实现的，而是通过文本替换实现的——X是“参数的符号标记”。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = SQUARE(<span class="number">5.0</span>); is replaced by a = <span class="number">5.0</span> * <span class="number">5.0</span>;</span><br><span class="line">b = SQUARE(<span class="number">4.5</span>+<span class="number">7.5</span>); is replaced by b = <span class="number">4.5</span> + <span class="number">7.5</span> * <span class="number">4.5</span> + <span class="number">7.5</span>;</span><br><span class="line">d = SQUARE(c++); is replaced by d = c++ * c++;</span><br></pre></td></tr></table></figure></p><p>上述示例只有第一个能正常工作。可以通过括号来改进：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) ((X)*(X))</span></span><br></pre></td></tr></table></figure></p><p>但仍然存在这样的问题，即宏不能按值传递。即使使用新的定义，SQUARE(C++)仍将c递增2次，但是之前的inline.cpp中的内联函数square()计算c的结果，传递它，以计算其平方值，然后将c递增一次。<br>这里的目的不是演示如何编写C宏，而是要指出，如果使用C语言的宏执行了类似函数的功能，应考虑将它们转换为C++内联函数。</p><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>C++新增了一种复合类型——引用变量。引用是一顶一的变量的别名(另一个名称)。例如，如果将twain作为element变量的引用，则可以交替使用twain和element来表示该变量。那么，这种别名有何作用呢？它的主要作用是用作函数的形参，通过引用变量作为参数，函数将使用原始数据，而不是其副本。这样，除指针以外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。</p><h4 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h4><p>C和C++使用&amp;符号来表示变量的地址。C++给&amp;符号赋予了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量的别名，可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rats;</span><br><span class="line"><span class="keyword">int</span> &amp; rodents = rats;<span class="comment">// makes rodents an alias for rats</span></span><br></pre></td></tr></table></figure></p><p>其中，&amp;不是地址运算符，而是类型标识符的一部分。就像声明中的char*指的是指向char的指针一样，int &amp;指的是指向int的引用。上述引用声明允许将rats和rodents呼唤——它们指向相同的值和内存单元，参看以下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// firstref.cpp -- defining and using a reference</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> rats = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; rodents = rats;<span class="comment">// rodents is a reference</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rats = "</span> &lt;&lt; rats;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", rodents = "</span> &lt;&lt; rodents &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">rodents++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rats = "</span> &lt;&lt; rats;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", rodents = "</span> &lt;&lt; rodents &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some implementations require type casting the following</span></span><br><span class="line"><span class="comment">// addresses to type unsigned</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rats address = "</span> &lt;&lt; &amp;rats;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", rodents address = "</span> &lt;&lt; &amp;rodents &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，下述语句中的&amp;运算符不是地址运算符，而是将rodents的类型声明为int &amp;，即指向int变量的引用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; rodents = rats;</span><br></pre></td></tr></table></figure></p><p>不过，下述语句中的&amp;则是地址运算符，其中&amp;rodents表示rodents引用的变量的地址：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", rodents address = "</span> &lt;&lt; &amp;rodents &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>下面是上述程序的输出：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rats = 101, rodents = 101</span><br><span class="line">rats = 102, rodents = 102</span><br><span class="line">rats<span class="built_in"> address </span>= 0x0065fd48, rodents<span class="built_in"> address </span>= 0x0065fd48</span><br></pre></td></tr></table></figure></p><p>从中可知，rats和rodents的值和地址都相同(具体的地址和显示格式随系统而异)。将rodents加1将影响这两个变量。更准确地说，rodents++操作将一个有两个名称的变量加1。</p><h4 id="将引用作为函数参数"><a href="#将引用作为函数参数" class="headerlink" title="将引用作为函数参数"></a>将引用作为函数参数</h4><p>引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法成为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。C++新增的这项特性是对C语言的超越，C语言只能按值传递。按值传递导致被调用函数使用调用程序的值的拷贝。当然，C语言也允许避开按值传递的限制，采用按指针传递的方式。<br>参看下列程序代码，它演示了几种交换两个变量的值的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swaps.cpp -- swapping with references and with pointers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapr</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;<span class="comment">// a, b are aliases for ints</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapp</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span>;<span class="comment">// p, q are addresses of ints</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapv</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;<span class="comment">// a,b are new variables</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> wallet1 = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> wallet2 = <span class="number">350</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wallet1 = $"</span> &lt;&lt; wallet1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" wallet2= $"</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Using reference to swap contents:\n"</span>;</span><br><span class="line">swapr(wallet1, wallet2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wallet1 = $"</span> &lt;&lt; wallet1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" wallet2= $"</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Using pointers to swap contents again:\n"</span>;</span><br><span class="line">swapp(&amp;wallet1, &amp;wallet2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wallet1 = $"</span> &lt;&lt; wallet1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" wallet2= $"</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Trying to use passing by value:\n"</span>;</span><br><span class="line">swapv(wallet1, wallet2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wallet1 = $"</span> &lt;&lt; wallet1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" wallet2= $"</span> &lt;&lt; wallet2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapr</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span><span class="comment">// use references</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = a;<span class="comment">// use a, b for values of variables</span></span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapp</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span><span class="comment">// use pointers</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = *p;<span class="comment">// use *p, *q for values of variables</span></span><br><span class="line">*p = *q;</span><br><span class="line">*q = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapv</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><span class="comment">// try using values</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是程序的输出：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wallet1 = $30<span class="number">0</span> wallet2 = $35<span class="number">0</span>&lt;&lt; original <span class="keyword">values</span></span><br><span class="line">Using references to swap contents:</span><br><span class="line">wallet1 = $35<span class="number">0</span> wallet2 = $30<span class="number">0</span>&lt;&lt; <span class="keyword">values</span> swapped</span><br><span class="line">Using pointers to swap contents:</span><br><span class="line">wallet1 = $30<span class="number">0</span> wallet2 = $35<span class="number">0</span>&lt;&lt; <span class="keyword">values</span> swapped again</span><br><span class="line">Trying to <span class="keyword">use</span> passing by value:</span><br><span class="line">wallet1 = $30<span class="number">0</span> wallet2 = $35<span class="number">0</span>&lt;&lt; swap failed</span><br></pre></td></tr></table></figure></p><p>正如预想那样，指针和引用方法都成功地交换了两个钱夹(wallet)中的内容，而按值传递的方法没能完成此项任务。<br>引用的其他使用方法我们将在后续学习。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记六</title>
      <link href="/2019/05/05/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
      <url>/2019/05/05/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<p>关于函数的一些内容<br><a id="more"></a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>没有返回值的函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">statement(s)</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">// optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，parameterList指定了传递给函数的参数类型与数量。<br>有返回值的函数将生成一个值，并将它返回给调用函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">typeName <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">statements</span><br><span class="line"><span class="keyword">return</span> value;<span class="comment">// value is type cast to type typeName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果函数包括多条返回语句，则在执行第一条返回语句时结束。</p><h3 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h3><p>考虑如下函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span><span class="comment">// arr = array name, n = size</span></span></span><br></pre></td></tr></table></figure></p><p>这看起来非常合理。方括号指出arr是一个数组，而方括号为空表明，可以将任意长度的数组传递给此函数。但实际上，arr并不是一个数组，而是一个指针。不过，在编写函数时，可以将arr看作是数组。  </p><h4 id="函数如何使用指针处理数组"><a href="#函数如何使用指针处理数组" class="headerlink" title="函数如何使用指针处理数组"></a>函数如何使用指针处理数组</h4><p>在大多数情况下，C++和C语言一样，将数组名视为指针。C++将数组名解释为第一个元素地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookies == &amp;cookies[<span class="number">0</span>];<span class="comment">// array name is address of first element</span></span><br></pre></td></tr></table></figure><p><strong>注意：只有当用于函数头或者函数原型时，int *arr和 int arr[]的含义才是相同的</strong><br>下列的恒等式值得记忆：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[i] == *(arr + i)</span><br><span class="line">&amp;arr[i] == arr + i</span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a>填充数组</h6><p>用于接受数组名参数的函数访问的是原始数组，而非其副本，因此可以通过调用该函数将值赋给数组元素。该函数的一个参数是要填充的数组名称。通常，不能在函数中设置数组长度，而要将数组长度作为第二个参数传递。由于用户输入的元素数目可能少于数组长度，因此函数应该返回实际输入的元素数目。因此，函数原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> ar[], <span class="keyword">int</span> limit)</span></span>;</span><br></pre></td></tr></table></figure></p><p>可以使用循环连续地将值读入到数组中，但如何提早结束呢？一种方法是，使用一个特殊值来指出输入结束。由于所有属性非负，可以使用负数来指出输入结束。另外，该函数应对错误输入作出反应，如停止输入等。这样，函数如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> ar[], <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> temp;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter value #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">cin</span>)<span class="comment">// bad input</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>.clear();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; input process terminated.\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">ar[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="显示数组及用const保护数组"><a href="#显示数组及用const保护数组" class="headerlink" title="显示数组及用const保护数组"></a>显示数组及用const保护数组</h6><p>为防止函数无意中修改数组的内容，可在声明形参时使用关键字const：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p><p>该声明表明，指针ar指向的是常量数据。这意味着不能使用ar修改该数据，也就是说，可以使用像ar[0]这样的值，但不能修改。下面是show_array()函数的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ar[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h6><p>在这个例子中，对数组进行的第三项操作是将每个元素与同一个重新评估因子相乘。需要给函数传递3个参数：因子、数组和元素数目。该函数不需要返回值，因此其代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">(<span class="keyword">double</span> r; <span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">ar[i] *= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于此函数将修改数组的值，因此在声明ar时，不能使用const。</p><h5 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h5><p>可以用两种不同方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值。第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。下面来看细节。首先，声明一个指向常量的指针pt：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">39</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;age;</span><br></pre></td></tr></table></figure></p><p>该声明指出，pt指向一个const int(这里为39)，因此不能使用pt来修改这个值。换句话来说，*pt的值为const，不能被修改：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt +=<span class="number">1</span>;<span class="comment">// INVALID because pt points to a const int</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; *pt;<span class="comment">// INVALID for the same reason</span></span><br></pre></td></tr></table></figure></p><p>现在有一个微妙的问题。pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt指向age，而age不是const。可以直接通过age变量来修改age的值，不能使用pt指针来修改它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt = <span class="number">20</span>;<span class="comment">// INVALID because pt points to a const int</span></span><br><span class="line">age = <span class="number">20</span>;<span class="comment">// VALID because age is not declared to be const</span></span><br></pre></td></tr></table></figure></p><p>以前我们将常规变量的地址赋给常规指针，而这里将常规变量的地址赋给const的指针。因此还有两种可能：将const变量的地址赋给const的指针、将const的地址赋给常规指针。这两种操作都可行吗？第一种可行，但第二种不可行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> g_earth = <span class="number">9.80</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> * pe = &amp;g_earth;<span class="comment">// VALID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> g_moon = <span class="number">1.63</span>;</span><br><span class="line"><span class="keyword">float</span> *pm = &amp;g_moon;<span class="comment">// INVALID</span></span><br></pre></td></tr></table></figure></p><p>对于第一种情况来说，既不能使用g_earth来修改值9.80，也不能使用pe来修改。C++禁止第二种情况的原因很简单——如果将g_moon的地址赋给pm，则可以使用pm来修改g_moon的值，这使得g_moon的const状态很荒谬，因此C++禁止将const的地址赋给非const指针。如果非要这样做，可以使用强制类型转换来突破限制，详情在之后讨论运算符const_cast是会提到。<br>如果将指针指向指针，则情况将更复杂。前面讲过，假如涉及的是一级间接关系，则将非const指针赋给const指针是可以的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">39</span>;<span class="comment">// age++ is a valid operation</span></span><br><span class="line"><span class="keyword">int</span> * pd = &amp;age;<span class="comment">// *pd = 41 is a valid operation</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = pd;<span class="comment">// *pt = 42 is an invalid operation</span></span><br></pre></td></tr></table></figure></p><p>然而，进入两级间接关系时，与一级间接关系一样，将const和非const混合的指针赋值方式将不再安全。如果允许这样做，则可以编写这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> **pp2;</span><br><span class="line"><span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">13</span>;</span><br><span class="line">pp2 = &amp;p1;<span class="comment">// not allowed, but suppose it were</span></span><br><span class="line">*pp2 = &amp;n;<span class="comment">// valid, but sets p1 to point at n</span></span><br><span class="line">*p1 = <span class="number">10</span>;<span class="comment">// valid, but changes const n</span></span><br></pre></td></tr></table></figure></p><p>上述代码将非const地址(&amp;p1)赋给了const指针(pp2)，因此可以使用p1来修改const数据。因此，当且仅当只有一层间接关系(如指针指向基本数据类型)时，才可以将非const地址或指针赋给const指针。<br><strong>注意：如果数据类型本身并不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针。</strong><br>假设有一个由const地址组成的数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> months[<span class="number">12</span>] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>则禁止将常量数组的地址赋给非常量指针将意味着不能将数组名作为参数传递给使用非常量形参的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;<span class="comment">// should have been const int arr[]</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> j = sum(months, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></p><p>上述函数调用试图将const指针(months)赋给非const指针(arr)，编译器将禁止这种函数调用。</p><h6 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h6><p>将指针参数声明为指向常量数据的指针有两条理由：</p><ul><li>这样可以避免由于无意间修改数据而导致的编程错误；</li><li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。如果条件允许，则应将指针形参声明为指向const的指针。</li></ul><p>为说明另一个微妙之处，请看下面的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">39</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;age;</span><br></pre></td></tr></table></figure></p><p>第二个声明中的const只能防止修改pt指向的值(这里为39)，而不能防止修改pt的值。也就是说，可以将一个新地址赋给pt：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sage = <span class="number">80</span>;</span><br><span class="line">pt = &amp;sage;<span class="comment">// okay to point to another location</span></span><br></pre></td></tr></table></figure></p><p>但仍然不能使用pt来修改它指向的值(现在为80)。<br>第二种使用const的方式使得无法修改指针的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sloth = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ps = &amp;sloth;<span class="comment">// a pointer to const int</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> finger = &amp;sloth;<span class="comment">// a const pointer to int</span></span><br></pre></td></tr></table></figure></p><p>在最后一个声明中，关键字const的位置与以前不同。这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。简而言之，finger和*ps都是const，而*finger和ps不是。<br>如果愿意，还可以声明指向const对象的const指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> trouble = <span class="number">2.0E30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> stick = &amp;trouble;</span><br></pre></td></tr></table></figure></p><p>其中，stick只能指向trouble，而stick不能用来修改trouble的值。简而言之，stick和*stick都是const。<br>通常，将指针作为函数形参来传递时，可以使用指向const的指针来保护数据。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p><p>在该声明中使用const意味着show_array()不能修改传递给它的数组中的值。只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针，则不能使用const。  </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记五</title>
      <link href="/2019/05/02/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
      <url>/2019/05/02/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<p>关于文件I/O的一些内容<br><a id="more"></a></p><h2 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入/输出"></a>简单文件输入/输出</h2><h3 id="文本I-O和文本文件"><a href="#文本I-O和文本文件" class="headerlink" title="文本I/O和文本文件"></a>文本I/O和文本文件</h3><p>我们这里讨论一下关于文本I/O的概念。当我们使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。不管目标数据类型是什么，输入一开始都是字符数据——文本数据。然后，cin对象负责将文本转换为其他类型。例如：<br>假设有如下输入行：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">38<span class="selector-class">.5</span> 19<span class="selector-class">.2</span></span><br></pre></td></tr></table></figure></p><p>首先，我们看一下char数据类型的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br></pre></td></tr></table></figure></p><p>输入行中的第一个字符被赋给ch。这里，第一个字符为3，其字符编码(二进制)被存储在变量ch中。输入和目标变量都是字符，因此不需要进行转换。注意，这里存储的数值3，而是字符3的编码。执行上述输入语句后，输入队列的下一个字符为字符8，下一个输入操作将对其进行处理。<br>接下来康康int类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br></pre></td></tr></table></figure></p><p>在这种情况下，cin将不断读取，直到遇到非数字字符。也即是，它将读取3和8，这样句点将成为输入队列的下一个字符，cin通过计算发现，这两个字符对应数值38，因此将38的二进制编码复制到变量n中。<br>接下来便是double类型了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br></pre></td></tr></table></figure></p><p>这种情况下，cin将不断读取，直至遇到第一个不属于浮点数的字符。也就是说，cin读取3、8、句点和5使得空格成为输入队列的下一个字符。cin通过计算发现，这四个字符对应数值38.5，因此将38.5的二进制编码(浮点格式)复制到变量x中。<br>那么char数组又如何？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> word[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; word;</span><br></pre></td></tr></table></figure></p><p>这种情况下，cin将不断读取，直到遇到空白字符。也即是，它读取3、8、句点和5。使得空格成为输入队列的下一个字符。然后，cin将这4个字符的编码存储到数组word中，并在末尾加上一个空字符。这里不需要进行任何转换。<br>最后便是另一种使用char数组的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> word[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(word, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></p><p>这种情况下，cin将不断读取直至遇上换行符(示例输入少于50个字符)。所有字符都将被存储到数组word中，并在末尾加上一个空字符。换行符被丢弃，输入队列中的下一个字符是下一行中的第一个字符。<br>我们这里讨论的I/O相当于控制台I/O，因此仅适用于文本文件。</p><h3 id="写入到文本文件"><a href="#写入到文本文件" class="headerlink" title="写入到文本文件"></a>写入到文本文件</h3><p>对于文件输入，C++使用类似于cout的东西。下面来复习一下：  </p><ul><li>必须包含头文件iostream。</li><li>头文件iostream定义了一个用于处理输出的ostream类。 </li><li>头文件iostream声明了一个名为cout的ostream变量(对象)。</li><li>必须指明名称空间std；例如，为引用元素cout和endl，必须使用编译指令using或前缀std::。</li><li>可以结合使用cout和运算符&lt;&lt;来显示各种类型的数据。  </li></ul><p>文件输出与此十分类似：  </p><ul><li>必须包含头文件fstream。</li><li>头文件fstream定义了一个用于处理输出的ofstream类。</li><li>需要声明一个或多个ofstream变量(对象)，并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。</li><li>必须指明名称空间std；例如，为引用元素ofstream，必须使用编译指令using或前缀std::。</li><li>需要将ofstream对象与文件关联起来。为此，方法之一是使用open()方法。</li><li>使用完文件后，应使用方法close()将其关闭。</li><li>可结合使用ofstream对象和运算符&lt;&lt;来输出各种类型的数据。  </li></ul><p>注意，虽然头文件iostream提供了一个预先定义好的名为cout的ostream对象，但必须声明自己的ofstream对象，为其命名，并将其与文件关联。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outFile;<span class="comment">// outFile an ofstream object</span></span><br><span class="line">ofstream fout;<span class="comment">// fout an ofstream object</span></span><br></pre></td></tr></table></figure></p><p>下面演示了如何将这种对象与特定的文件关联起来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outFile.open(<span class="string">"fish.txt"</span>);<span class="comment">// outFile used to write to the fish.txt file</span></span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; filename;<span class="comment">// user specifies a name</span></span><br><span class="line">fout.open(filename);<span class="comment">// fout used to read specified file</span></span><br></pre></td></tr></table></figure></p><p>注意，方法open()接受一个C-风格字符串作为参数，这可以是一个字面字符串，也可以是存储在数组中的字符串。<br>下面演示了如何使用这种对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> wt = <span class="number">125.8</span>;</span><br><span class="line">outFile &lt;&lt; wt;<span class="comment">// write a number to fish.txt</span></span><br><span class="line"><span class="keyword">char</span> line[<span class="number">81</span>] = <span class="string">"Objects are closer than they appear."</span>;</span><br><span class="line">fout &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// write a line of text</span></span><br></pre></td></tr></table></figure></p><p>重要的是，声明一个ofstream对象并将其同文件关联起来后，便可以像使用cout那样使用它。所有可用于cout的方法(如&lt;&lt;、endl和setf())都可用于ofstream对象(如前述示例中的outFile和fout)。<br>总之，使用文件输出的主要步骤如下：  </p><ol><li>包含头文件fstream。  </li><li>创建一个ofstream对象。  </li><li>将该ofstream对象同一个文件关联起来。  </li><li>就像使用cout那样使用该ofstream对象。  </li></ol><p>下列程序演示了这种方法。它要求用户输入信息，然后将信息显示到屏幕上，再将这些信息写入到文件中。读者可以使用文本编辑器来查看该输出文件内容。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//outfile.cpp -- writing to a file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> automobile[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">double</span> a_price;</span><br><span class="line"><span class="keyword">double</span> d_price;</span><br><span class="line"></span><br><span class="line">ofstream outFile;<span class="comment">// create object for output</span></span><br><span class="line">outFile.open(<span class="string">"carinfo.txt"</span>);<span class="comment">// associate with a file</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the make and model of automobile: "</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(automobile, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the model year: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; year;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the original asking price: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a_price;</span><br><span class="line">d_price = <span class="number">0.913</span>*a_price;</span><br><span class="line"></span><br><span class="line"><span class="comment">// display information on screen with cout</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed;</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span>.setf(ios_base::showpoint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Make and model: "</span> &lt;&lt; automobile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Year: "</span> &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Was asking $"</span> &lt;&lt; a_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Now asking $"</span> &lt;&lt; d_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now do exact same things using outFile instead of cout</span></span><br><span class="line"></span><br><span class="line">outFile &lt;&lt; fixed;</span><br><span class="line">outFile.precision(<span class="number">2</span>);</span><br><span class="line">outFile.setf(ios_base::showpoint);</span><br><span class="line">outFile &lt;&lt; <span class="string">"Make and model: "</span> &lt;&lt; automobile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"Year: "</span> &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"Was asking $"</span> &lt;&lt; a_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"Now asking $"</span> &lt;&lt; d_price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">outFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该程序的最后一部分与cout部分相同，只是将cout替换为outFile而已。下面是该程序的运行情况：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/outfile.cpp输出.png" alt="输出"><br>屏幕输出使用的是cout的结果。如果我们查看源文件outfile.cpp的目录，将看到一个名为carinfo.txt的新文件，其中包含outFile生成的输出。打开文本编辑器，显示如下：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/outfile.cpp文本输出.png" alt="文本输出"><br>正如你们所见，outFile将屏幕上的内容写入到了文件carinfo.txt中。</p><h4 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h4><p>在程序中，声明一个ofstream对象后，便可以使用方法open()将该对象和特定文件关联起来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outFile;<span class="comment">// create object for output</span></span><br><span class="line">outFile.open(<span class="string">"carinfo.txt"</span>);<span class="comment">// associate with a file</span></span><br></pre></td></tr></table></figure></p><p>程序使用完该文件后，应当将其关闭：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.close();</span><br></pre></td></tr></table></figure></p><p>需要注意的是，方法close()不需要参数，这是因为outFile已经同特定的文件关联起来了。如果忘记关闭文件，程序正常终止时将自动关闭它。<br>outFile可以使用cout可使用的任何方法。它不但能够使用运算符&lt;&lt;，还可以使用各种格式化方法，如self()和precision()。这些方法只影响调用它们的对象。例如，对于不同的对象，可以提供不同的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>);<span class="comment">// use a precision of 2 for the display</span></span><br><span class="line">outFile.precision(<span class="number">4</span>);<span class="comment">// use a precision of 4 for the display</span></span><br></pre></td></tr></table></figure></p><p>需要记住的是，创建好ofstream对象后(如outFile)后，便可以像使用cout一样使用它。<br>回到open()：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.open(<span class="string">"carinfo.txt"</span>);</span><br></pre></td></tr></table></figure></p><p>在这里，运行程序之前，文件carinfo.txt并不存在，这种情况下，方法open()将新建一个名为carinfo.txt的文件。如果在此时运行该程序，则文件carinfo.txt存在，情况何如？默认情况下，open()将截断该文件，即将其长度截短到零——丢弃原有的内容，然后将新的输出加入到该文件中。之后我们将学习如何更改这种默认行为。<br><strong>警告：打开已有的文件，以接受输出时，默认将它长度截短为零，因此原来的内容将丢失。</strong><br>打开文件用于接受输入时可能失败。例如，指定的文件可能已经存在，但禁止对其进行访问。因此，细心的程序员将检查打开文件的操作是否成功，这将在下一个例子中介绍。</p><h3 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h3><p>接下来介绍文本文件输入，它是基于控制台输入的。控制台输入涉及多个方面，下面首先来进行总结：  </p><ul><li>必须包含头文件iostream。</li><li>头文件iostream定义了一个用于处理输入的istream类。</li><li>头文件iostream声明了一个名为cin的istream变量(对象)。</li><li>必须指明名称空间std；例如，为引用元素cin，必须使用编译指令using或前缀std::。</li><li>可以结合使用cin和运算符&gt;&gt;来读取各种类型的数据。</li><li>可以使用cin和get()方法来读取一个字符，使用cin和getline()来读取一行字符。</li><li>可以结合使用cin和eof()、fail()方法来判断输入是否成功。</li><li>对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。</li></ul><p>文件输出与此极其相似：</p><ul><li>必须包含头文件fstream。</li><li>头文件定义了一个用于处理输入的ifstream类。</li><li>需要声明一个或多个ifstream变量(对象)，并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。</li><li>必须指明名称空间std；例如，为引用元素ifstream必须使用编译指令using或前缀std::。</li><li>需要将ifstream对象与文件关联起来。为此，方法之一时使用open()方法。</li><li>使用完文件后，应使用close()方法将其关闭。</li><li>可结合使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据。</li><li>可以使用ifstream对象和get()方法来读取一个字符，使用ifstream对象和getline()来读取一行字符。</li><li>可以结合使用ifstream和eof()、fail()等方法来判断输入是否成功。</li><li>ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。</li></ul><p>注意，虽然头文件iostream提供了一个预先定义好的名为cin的istream对象，但必须声明自己的ifstream对象，为其命名，并将其同文件关联起来。下面演示了如何声明这种对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream inFile;<span class="comment">// inFile an ifstream object</span></span><br><span class="line">ifstream fin;<span class="comment">// fin an ifstream object</span></span><br></pre></td></tr></table></figure></p><p>下面演示了如何将这种对象与特定的文件关联起来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inFile.open(<span class="string">"bowling.txt"</span>);<span class="comment">// inFile used to read bowling.txt file</span></span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; filename;<span class="comment">// user specifies a name</span></span><br><span class="line">fin.open(filename);<span class="comment">// fin used to read specified file</span></span><br></pre></td></tr></table></figure></p><p>注意，方法open()接受一个C-风格字符串作为参数，这可以是一个字面字符串，也可以是存储在数组中的字符串。<br>下面演示了如何使用这种对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> wt;</span><br><span class="line">inFile &gt;&gt; wt;<span class="comment">// read a number from bowling.txt</span></span><br><span class="line"><span class="keyword">char</span> line[<span class="number">81</span>];</span><br><span class="line">fin.getline(line, <span class="number">81</span>);<span class="comment">// read a line of text</span></span><br></pre></td></tr></table></figure></p><p>重要的是，声明一个ifstream对象并将其同文件关联起来后，便可以像使用cin那样使用它。所有用于cin的操作和方法都可用于ifstream对象(如前述示例中的inFile和fin)。<br>如果试图打开一个不存在的文件用于输入，情况何如？这种错误将导致后面使用ifstream对象进行输入时失败。检查文件是否被成功打开的首先方法是使用方法is_open()，为此，可以使用类似于下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inFile.open(<span class="string">"bowling.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!inFile.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果文件被成功地打开，方法is_open()将返回true；因此如果文件没有被打开，表达式!inFile.is_open()的值将为true。函数exit()的原型是在头文件cstdlib中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值EXIT_FAILURE。函数exit()终止程序。下图是cstdlib对EXIT_FAILURE的定义。<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/cstdlib中对于EXIT_FAILURE的定义.png" alt="定义"><br>相对的，cstdlib中也存在参数值EXIT_SUCCESS，它的定义是：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/cstdlib中对于EXIT_SUCCESS的定义.png" alt="定义"><br>方法is_open()是C++中相对较新的内容。如果读者编译器不支持它，可以使用较老的方法good()代替。在后面的学习中会讨论，方法good()在检查可能存在的问题方面，没有is_open()那么广泛。<br>下列程序打开用户指定的文件，读取器中的数字，然后指出文件中包含多少个值以及它们的和与平均值。正确地设计输入循环至关重要。详细请看后面地“程序说明”。注意，通过使用if语句，该程序受益匪浅。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sumafile.cpp -- functions with an array argument</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;// file I/O support</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;// support for exit()</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">60</span>];</span><br><span class="line">ifstream inFile;<span class="comment">// object for handling file input</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter name of data file: "</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(filename, SIZE);</span><br><span class="line">inFile.open(filename);<span class="comment">// associate inFile with a file</span></span><br><span class="line"><span class="keyword">if</span> (!inFile.is_open())<span class="comment">// failed to open file</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not open the file "</span> &lt;&lt; filename &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Program terminating.\n"</span>;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> value;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// number of items read</span></span><br><span class="line"></span><br><span class="line">inFile &gt;&gt; value;<span class="comment">// get first value</span></span><br><span class="line"><span class="keyword">while</span> (inFile.good())<span class="comment">// while input good and not at EOF</span></span><br><span class="line">&#123;</span><br><span class="line">++count;<span class="comment">// one more item read</span></span><br><span class="line">sum += value;<span class="comment">// calculate running total</span></span><br><span class="line">inFile &gt;&gt; value;<span class="comment">// get next value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inFile.eof())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"End of file reached.\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (inFile.fail())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by data mismatch.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by unknown reason.\n"</span>;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No data processed.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Items read: "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Average: "</span> &lt;&lt; sum / count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">inFile.close();<span class="comment">// finished with the file</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要运行上述程序，首先必须创建一个包含数字的文本文件。为此，可以使用文本编辑器(如用于编写源代码的文本编辑器)。假设该文件名为scores.txt，包含的内容如下：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/scores.txt.png" alt="文本文档"><br><strong>警告：Windows文本文件的每一行都以回车字符和换行符结尾；通常情况下，C++再读取文件时将这两个字符转换为换行符，并在写入文件时执行相反的转换。有些文本编辑器(如Metroweeks Code Warrior IDE编辑器)，不会自动在最后一行末尾加上换行符。因此，如果读者使用的是这种编辑器，请在输入最后的文本后按下回车键，然后在保存文件。</strong><br>下面是该程序的运行情况：<br><img src="/2019/05/02/C++-Primer-Plus-学习笔记五/sumafile.cpp输出.png" alt="输出">    </p><h4 id="程序说明-1"><a href="#程序说明-1" class="headerlink" title="程序说明"></a>程序说明</h4><p>该程序没有使用硬编码文件名，而是将用户提供的文件名存储到字符数组filename中，然后将该数组用作open()的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inFile.open(filename);</span><br></pre></td></tr></table></figure></p><p>特别需要注意的是循环的正确设计。读取文件时，有几点需要检查。首先，程序读取文件时不应超过EOF。如果最后一次读取数据时遇到EOF，方法eof()将返回true。其次，程序可能遇到类型不匹配的情况。例如，上述程序期望文件中只包含数字。如果最后一次读取操作发生了类型不匹配的情况，方法fail()将返回true(如果遇到了EOF，该方法也将返回true)。最后，可能出现意外的问题还有很多，如文件受损或硬件故障。如果最后一次读取文件时发生了这样的问题，方法bad()将返回true。不要分别检查这些情况，一种更简单的方法是使用good()方法，该方法在没有发生任何错误时返回true：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (inFile.good())<span class="comment">// while input good and not at EOF</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，如果愿意，可以用其他方法来确定循环终止的真正原因：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inFile.eof())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"End of file reached.\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (inFile.fail())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by data mismatch.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input terminated by unknown reason.\n"</span>;</span><br></pre></td></tr></table></figure></p><p>这些代码紧跟在循环的后面，用于判断循环为何终止。由于eof()只能判断是否到达EOF，而fail()可用于检查EOF和类型不匹配，因此上述代码首先判断是否到达EOF。这样，如果执行到了else if测试，便可排除EOF，因此，如果fail()返回true，便可断定导致循环终止的原因是类型不匹配。<br>方法good()指出最后一次读取输入的操作是否成功，这十分重要。这意味着应该在执行读取输入操作后，立刻应用这种测试。为此，一种标准方法是，在循环之前(首次执行循环测试前)放置一条输入语句，并在循环的末尾(下次执行循环测试之前)放置另一条输入语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// standard file-reading loop design</span></span><br><span class="line">inFile &gt;&gt; value;<span class="comment">// get first value</span></span><br><span class="line"><span class="keyword">while</span> (inFile.good())<span class="comment">// while input good and not at EOF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// loop body goes here</span></span><br><span class="line">inFile &gt;&gt; value;<span class="comment">// get next value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>鉴于以下事实，可以将上述代码精简：表达式inFile &gt;&gt; value的结果为inFile，而在需要一个bool值的情况下，inFile的结果为inFile.good()，即true或false。<br>因此，可以将两条输入语句用一条用作循环测试的输入语句代替。也就是说，可以将上述循环结构替换为如下循环结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abbreviated file-reading loop design</span></span><br><span class="line"><span class="comment">// omit pre-loop input</span></span><br><span class="line"><span class="keyword">while</span> (inFile &gt;&gt; value)<span class="comment">// read and test for success</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//loop body goes here</span></span><br><span class="line"><span class="comment">// omit end-of-loop input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此种设计仍然遵循了在测试之前进行读取的规则，因为要计算表达式inFile &gt;&gt; value的值，程序首先试图将一个数据读取到value中。<br>至此，我们对文件I/O有了初步的认识。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法谜题二</title>
      <link href="/2019/04/29/%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98%E4%BA%8C/"/>
      <url>/2019/04/29/%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>这是《算法谜题》中的第4到第6题。<br><a id="more"></a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="简单谜题"><a href="#简单谜题" class="headerlink" title="简单谜题"></a>简单谜题</h3><h4 id="士兵摆渡"><a href="#士兵摆渡" class="headerlink" title="士兵摆渡"></a>士兵摆渡</h4><h5 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h5><p>25个士兵组成的小分队需要渡河，可是河宽且水深，周围也看不到桥。他们发现河岸边有一个小船，两个12岁的男孩正在上面玩耍。船很小，仅能承载两个男孩或一个士兵的重量。士兵应怎样渡河？在你用的算法中，船从一个岸边到另一个岸边来回共计几次？</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><p>考虑到船一次只能载一个士兵，那么每一次就有一个士兵驾船前去对岸，再由1个小孩驾船回来。一次可以将2个小孩运载至对岸。那么过程就很清晰了：2个男孩过河-&gt;1个男孩回来-&gt;一个士兵过河-&gt;另1个男孩驾船回来，重复至所有士兵都渡河完成。那么这样一来，船一共靠岸100次。</p><h5 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">soldiersCrossRiver</span><span class="params">(<span class="keyword">int</span> numberOfSoldiers)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!allSolidersAreCrossed())&#123;</span><br><span class="line">boat.SendPeople(boy1, boy2, there);<span class="comment">// boat.SendPeople(object1, object2, toPlace);</span></span><br><span class="line">boat.SendPeople(boy1, here);<span class="comment">// boat.SendPeople(object, toPlace)</span></span><br><span class="line">boat.SendPeople(soldier, there);</span><br><span class="line">boat.SendPeople(boy2, here);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="行列变换"><a href="#行列变换" class="headerlink" title="行列变换"></a>行列变换</h4><h5 id="题目概述-1"><a href="#题目概述-1" class="headerlink" title="题目概述"></a>题目概述</h5><!--使用<p align="left/right/center">进行居左/居右/居中操作 --><p><img src="/2019/04/29/算法谜题二/图2.1 行列变换前的数字阵列.png" alt="变换前">  </p><p></p><p align="center">图2.1 行列变换前的数字阵列<br><img src="/2019/04/29/算法谜题二/图2.1 行列变换后的数字阵列.png" alt="变换后"><br>图2.1 行列变换后的数字阵列  </p><br>怎样才能将图一中的数字阵列进行变换得到图二？要求只能进行行列变换。<p></p><h5 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h5><p>线性代数的知识告诉我们，对行列式进行行列变换不改变元素的相对位置。因此答案是不可以的。</p><h5 id="伪代码实现-1"><a href="#伪代码实现-1" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在的</span></span><br></pre></td></tr></table></figure><h4 id="数数的手指"><a href="#数数的手指" class="headerlink" title="数数的手指"></a>数数的手指</h4><h5 id="题目概述-2"><a href="#题目概述-2" class="headerlink" title="题目概述"></a>题目概述</h5><p>一个小女孩正在用左手手指数数，从1数到1000。她从拇指算作1开始数起，然后，食指为2，中指为3，无名指为4，小指为5。接下来调转方向，无名指算作6，中指为7，食指为8，大拇指为9，接下来，食指算作10，如此反复。问如果她继续按这种方式数下去，最后结束时是停在哪根手指上？</p><h5 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h5><p>我们不妨先看下前几个数字，找找规律：<br><img src="/2019/04/29/算法谜题二/数字特征.png" alt="数字特征">   </p><p></p><p align="center">前几位数字与手指的匹配规律  </p><br>具体的判断方法就不用我多说了8。当数数到1000时，对应的手指是食指。<p></p><h5 id="伪代码实现-2"><a href="#伪代码实现-2" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Finger <span class="title">getTheFinger</span><span class="params">(<span class="keyword">int</span> countNumber)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> preCaculateNum = countNumber % <span class="number">8</span>;</span><br><span class="line">Finger result;</span><br><span class="line"><span class="keyword">switch</span> (preCaculateNum)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: result.setFinger(thumb); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">0</span>: result.setFinger(foreFinger); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">7</span>: result.setFinger(middleFinger); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">6</span>: result.setFinger(ringFinger); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: result.setFinger(littleFinger); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: result.setFinger(<span class="keyword">null</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法谜题一</title>
      <link href="/2019/04/27/%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98%E4%B8%80/"/>
      <url>/2019/04/27/%E7%AE%97%E6%B3%95%E8%B0%9C%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>唔，总算还是开始了算法的学习与研究了。在这里写下每天做出来的算法题吧。<br><a id="more"></a></p><h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h2><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p><h2 id="我使用的书籍——《算法谜题》"><a href="#我使用的书籍——《算法谜题》" class="headerlink" title="我使用的书籍——《算法谜题》"></a>我使用的书籍——《算法谜题》</h2><p>《算法谜题》是一本经典算法谜题的合集。书中包括了一些古已有之的谜题，数学和计算机科学有一部分知识就发源于此。 《算法谜题》可以为对算法感兴趣的广大读者提供系统丰富而实用的资料，能够帮助读者提升高阶算法思维能力。《算法谜题》适合计算机专业的高校教师和学生，想要培养和训练算法思维和计算思维的IT专业人士，以及在准备面试的应聘者和面试官阅读参考。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="简单谜题"><a href="#简单谜题" class="headerlink" title="简单谜题"></a>简单谜题</h3><h4 id="狼羊菜过河"><a href="#狼羊菜过河" class="headerlink" title="狼羊菜过河"></a>狼羊菜过河</h4><h5 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h5><p>一个人在河边，带着一匹狼、一只羊和一颗卷心菜，<br>他需要用船将这三样东西运至对岸，然而，这艘船的空间有限，只容得下他自己和另一样东西(或狼或羊或卷心菜)。<br>若他不在场看管的话，狼就会去吃羊，羊就会去吃卷心菜。此人如何才能把这三个“乘客”都送至对岸？  </p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><p>我们首先考虑第一次移动，如果移动菜或者狼，那么剩下的对象就会“冲突”，因此我们将羊作为第一次移动的目标。人再回到这边，接下来有两个选项，载菜或者载狼，首先考虑载狼吧，把狼载过去，再把羊载回来，这边再把菜带过去，然后回来接羊，任务完成。那么载菜又如何呢，把菜载过去，再回来接羊，任务也完成了。不过，第一种方案似乎要更为简洁。</p><h5 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">crossTheRiver</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isOk(there))&#123;<span class="comment">// 当对岸没有达到要求时</span></span><br><span class="line">tryMove(object);<span class="comment">// 尝试移动一个对象</span></span><br><span class="line">checkAvailable(here);<span class="comment">// 检查此边是否冲突</span></span><br><span class="line">checkAvailable(there);<span class="comment">// 检查对面是否冲突</span></span><br><span class="line"><span class="keyword">if</span>(isAvailable(here)&amp;&amp;isAvailable(there))<span class="comment">// 如果两边都可以</span></span><br><span class="line">Move(object);<span class="comment">// 移动对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 完成后返回真值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手套问题"><a href="#手套问题" class="headerlink" title="手套问题"></a>手套问题</h4><h5 id="题目概述-1"><a href="#题目概述-1" class="headerlink" title="题目概述"></a>题目概述</h5><p>抽屉中有20只手套。其中5双黑手套，3双棕色手套和2双灰手套。你只能在黑暗中挑手套，并且只有将手套挑出之后才能检查其颜色。最多要挑几次才能满足以下条件？<br>(a)至少挑出一双颜色匹配的手套。<br>(b)所有颜色的手套都至少挑出一双匹配的。</p><h5 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h5><p>(a)考虑最坏的情况：摸了10次，10双手套的一只都在手上了，那么再来一次就可以配上一双了。所以答案是11次。<br>(b)同样的，考虑极端坏的情况：把5双黑的摸齐了，3双棕色的也不放过，就差一只灰色的了，一共就是5×2+3×2+1+1+1=19次(灰色手套2只单的加上最后凑上双)</p><h5 id="伪代码实现-1"><a href="#伪代码实现-1" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鄙人才疏学浅，不会</span></span><br></pre></td></tr></table></figure><h4 id="矩形切割"><a href="#矩形切割" class="headerlink" title="矩形切割"></a>矩形切割</h4><h5 id="题目概述-2"><a href="#题目概述-2" class="headerlink" title="题目概述"></a>题目概述</h5><p>找出所有将一个矩形分成n个直角三角形的方法(n&gt;1)。并且将这种切割的方法归纳成一个算法。</p><h5 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h5><p>当n=2时，很容易考虑到对角线，一个对角线将一个矩形分为两个直角三角形。那么，当n&gt;2时，又该怎么办呢？我们不妨在直角三角形中作高线，这条高线将这个直角三角形分成了两个新的直角三角形。那么，答案就显而易见了：沿对角线切割，然后找到一个直角三角形作出高线，直到数目达到要求。</p><h5 id="伪代码实现-2"><a href="#伪代码实现-2" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seperateRectangle</span><span class="params">(<span class="keyword">int</span> triangleRequired, Rectangle rectangle)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(numOfTriangle &lt; triangleRequired)&#123;<span class="comment">// 当数目不足时进行分割</span></span><br><span class="line"><span class="keyword">if</span> (numOfTriangle == <span class="number">0</span>)&#123;<span class="comment">// 当第一次进行分割时</span></span><br><span class="line">linkDiagonal();<span class="comment">// 连接(矩形的)对角线</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Triangle triangle = <span class="keyword">new</span> findTriangle(rectangle)<span class="comment">// 找到一个所需要的直角三角形</span></span><br><span class="line">drawTriangleAltitude(triangle);<span class="comment">// 作出高线</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 学习笔记一</title>
      <link href="/2019/04/13/html5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2019/04/13/html5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>HTML5的示例网页与简要分析。<br><a id="more"></a><br>嗯，基于种种原因我开始了HTML5的学习。所用教材为《HTML5程序设计(第2版)》<br>那么首先我们进入第一个章节——关于HTML5。  </p><h1 id="HTML5的新功能"><a href="#HTML5的新功能" class="headerlink" title="HTML5的新功能"></a>HTML5的新功能</h1><h2 id="新的DOCTYPE和字符集"><a href="#新的DOCTYPE和字符集" class="headerlink" title="新的DOCTYPE和字符集"></a>新的DOCTYPE和字符集</h2><p>下面是一段HTML4 DOCTYPE代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"</span></span><br><span class="line"><span class="meta">"http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个似乎有点长，难以记忆，我们往往只能使用复制粘贴的方式来解决这个问题，同时也存在复制错误的可能性。<br>对于<br>这个问题，HTML5给出了漂亮的解决方案：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在的DOCTYPE好记多了。和它一样，字符集的声明也简化了许多。下面是过去的代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在成了：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当然，使用HTML5的DOCTYPE会触发浏览器以标准兼容模式显示页面。众所周知，Web页面有多种显示模式，如怪异模式(Quirks)、近标准模式(Almost Standards)以及标准模式(Standards)，其中标准模式也称作非怪异模式(no-quirks)。浏览器根据DOCTYPE识别该使用哪种模式，并且根据它来确定使用什么规则验证页面。怪异模式下，浏览器尽量不中断显示，即使没有完全通过验证也会显示出来。HTML5引入了新的标记元素和其他机制，因此如果坚持使用废弃的元素，页面将通不过验证。</p><h2 id="新元素和旧元素"><a href="#新元素和旧元素" class="headerlink" title="新元素和旧元素"></a>新元素和旧元素</h2><p>HTML5引入了很多新元素，根据类型不同，分为了7大类，如下表所示：<br><!--表格类内容牺牲了排版，因为hexo next有bug，会留下大段空白--></p><p><table><thead><tr><th>内容类型</th><th>描述</th></tr></thead><tbody><tr><td>内嵌</td><td>向文档中添加其他类型的内容，例如audio、video、canvas和iframe等</td></tr><tr><td>流</td><td>在文档和应用的body中使用的元素，例如form、h1和small等</td></tr><tr><td>标题</td><td>段落标题，例如h1、h2和hgroup等</td></tr><tr><td>交互</td><td>和用户交互的内容，例如音频和视频控件、button和textarea等</td></tr><tr><td>元数据</td><td>通常出现在页面的head中，设置页面其他部分的表现和行为，例如script、style和title等</td></tr><tr><td>短语</td><td>文本和文本标记元素，例如mark、kbd、sub和sup等</td></tr><tr><td>片段</td><td>用于定义文档中片段的元素，例如article、aside和title等</td></tr></tbody></table><br>上述所有类型的元素都可以通过CSS来设定样式。此外，其中一些元素，如canvas、audio和video，在使用时往往需要其他API来配合，以实现细粒度控制，但也可以直接使用。这将在后续进行学习。</p><h2 id="语义化标记"><a href="#语义化标记" class="headerlink" title="语义化标记"></a>语义化标记</h2><p>Google分析了上百万的页面，发现了DIV标签的通用ID名称重复量很大。所以引入了一组新的片段类元素进入HTML5，在目前主流浏览器中已经可以使用了，如下表：<br><!--排版原因同上--></p><p><table><thead><tr><th>元素名</th><th>描述</th></tr></thead><tbody><tr><td>header</td><td>标记头部区域的内容(用于整个页面或页面中的一块区域)</td></tr><tr><td>footer</td><td>标记脚部区域的内容(用于整个页面或页面中的一块区域)</td></tr><tr><td>section</td><td>Web页面中的一块区域</td></tr><tr><td>article</td><td>独立的文章内容</td></tr><tr><td>aside</td><td>相关内容或者引文</td></tr><tr><td>nav</td><td>导航类辅助内容</td></tr></tbody></table><br>同样，上述所有元素也可以用CSS设定样式。<br>下面是一个HTML5页面的概貌，其中使用了新的DOCTYPE、字符集和语义化标记元素——新的片段类元素。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- test.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"test.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Subtitle<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>HTML5 Rocks!<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Nav<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com"</span>&gt;</span>link 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com"</span>&gt;</span>link 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com"</span>&gt;</span>link 3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Article Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor HTML5 nunc aut nunquam sit amet, consectetur adiplscing</span><br><span class="line">elit.Vivamus at</span><br><span class="line">est eros, vel fringilla urna.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Article Footer<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Article Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>HTML5:"Lorem ipsum dolor nunc aut nunquam sit amet, consectetur adipiscing</span><br><span class="line">elit. Vivamus at est eros, vel fringilla urna. Pellentesque odio</span><br><span class="line">rhoncus<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Article Footer<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Aside<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>HTMP5:"Lorem ipsum dolor nunc qut nunquam sit amet, consectetur adipiscing</span><br><span class="line">elit. Vivamus at est eros, vel fringilla urna. Pellentesque odio</span><br><span class="line">rhoncus<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Footer<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>没有样式的页面看起来很逊。下面是一些可以用来设置内容样式的CSS代码。需要注意的是，它使用了CSS3的一些新特性，例如圆角(border-radius)和旋转变换(transform:rotate())。CSS3同HTML5一样正在开发，为了便于浏览器逐步支持，也采用了模块化的发布子规范，例如变换(transformation)、动画(animation)和过渡(transition)分别对应不同的子规范。<br>CSS3规范可能会变动，功能也处于实验期，为了避免命名空间冲突，功能都会加上浏览器厂商的前缀。要显示圆角、渐变(gradients)、阴影(shadows)和变形(transformations)的话，需要在声明的部分加上前缀：-moz-(Mozilla浏览器)、o-(Opear浏览器)和-webkit-(Safari和Chrome等基于WebKit核心的浏览器)。<br>下面是对应上面HTML5页面的CSS文件的源码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#CCCCCC</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Geneva, Arial, Helvetica, sans-serif;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">900px</span>;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">#FFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">72px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h4</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">-webkit-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">20px</span> <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">    <span class="attribute">-moz-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">20px</span> <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">3px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#888</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-webkit-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">20px</span> <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(-10deg);</span><br><span class="line">    <span class="attribute">-moz-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">20px</span> <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(-10deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">footer</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* links */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F47D31</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果就请读者自行验证。</p>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记四</title>
      <link href="/2019/04/10/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
      <url>/2019/04/10/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>关于循环的一些内容<br><a id="more"></a></p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="编写延时循环"><a href="#编写延时循环" class="headerlink" title="编写延时循环"></a>编写延时循环</h3><p>有时候，我们需要让程序等待一段时间。在之前的C语言课程设计之中，使用了Sleep(int milliseconds)函数来处理这个事情。while循环也可用于这种目的，一种早期的用于个人计算机的技术是，让其进行计数，以等待一段时间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> wait = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (wait &lt; <span class="number">10000</span>)</span><br><span class="line">wait++;<span class="comment">// counting silently</span></span><br></pre></td></tr></table></figure></p><p>但潜在的问题是这受到计算机处理器处理速度的影响。更好的方法是用系统时钟来完成此项工作。<br>ANSI C和C++库中有一个函数有助于完成这样一项工作。这个函数就是clock()，返回程序开始执行后所用的系统时间。这有几个问题：首先，返回的时间单位不一定为秒；其次，返回值的类型与系统有关，可能是long也可能是unsigned long或其他。<br>头文件ctime(较早的实现中使用time.h)提供了解决方案。首先，它定义了一个符号常量——CLOCKS_PER_SEC，该常量等于每秒钟包含的系统时间单位数。因此将系统时间除以这个常量可以得到秒数，或是将秒数诚意CLOCK_PER_SEC就可以得到以系统时间单位为单位的时间。其次，ctime将clock_t作为clock()返回类型的别名(将会在后面提起)，这意味着可以将变量声明为clock_t类型，编译器将进行转换以适应系统。<br>下列程序演示了使用clock()和头文件ctime创建延时循环：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// waiting.cpp -- using clock() in a time-delay loop</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;// describes clock() function, clock_t type</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the delay time, in seconds: "</span>;</span><br><span class="line"><span class="keyword">float</span> secs;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; secs;</span><br><span class="line"><span class="keyword">clock_t</span> delay = secs * CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"starting\a\n"</span>;</span><br><span class="line"><span class="keyword">clock_t</span> start = clock();</span><br><span class="line"><span class="keyword">while</span> (clock() - start &lt; delay);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"done \a\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该程序以系统时间为单位计算延迟时间，避免了在每轮循环中将系统时间转换为秒。  </p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>C++为类型建立别名的方式有两种。一种是使用预处理器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BYTE char <span class="comment">// preprocessor replaces BYTE with char</span></span></span><br></pre></td></tr></table></figure></p><p>这样，预处理器将在编译程序时用char替换所有的BYTE，从而使BYTE成为char的别名。<br>第二种方法是使用C++(和C)的关键字typedef来创建别名。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> type;</span><br></pre></td></tr></table></figure></p><p>下面是通用格式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> typeName aliasName;</span><br></pre></td></tr></table></figure></p><p>换句话说，如果要将aliasName作为某种类型的别名，可以声明aliasName，如同将aliasName声明为这种类型的变量那样，然后在声明的前面加上关键字typedef。例如，要让byte_pointer成为char指针的别名，可将byte_pointer声明为char指针，然后在前面加上typedef：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * byte_pointer;<span class="comment">// pointer to char type</span></span><br></pre></td></tr></table></figure></p><p>也可以使用#define，不过声明一系列变量时，这种方法不适用。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOAT_POINTER float *</span></span><br><span class="line">FLOAT_POINTER pa, pb;</span><br></pre></td></tr></table></figure></p><p>预处理器将声明转换为这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> * pa, pb;<span class="comment">// pa a pointer to float, pb just a float</span></span><br></pre></td></tr></table></figure></p><p>typedef方法不会有这样的问题。它能够处理更复杂的类型别名。<br><strong>注意，typedef不会创建新类型，</strong>而只是为已有的类型创建一个新名称。  </p><h3 id="基于范围的for循环-C-11"><a href="#基于范围的for循环-C-11" class="headerlink" title="基于范围的for循环(C++11)"></a>基于范围的for循环(C++11)</h3><p>C++11新增了一种循环：基于范围(range-based)的for循环。这简化了一种常见的循环任务：对数组(或容器类，如vector和array)的每个元素执行相同的操作，如下例所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">4.99</span>, <span class="number">10.99</span>, <span class="number">6.87</span>, <span class="number">7.99</span>, <span class="number">8.49</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> x : prices)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>其中，x最初表示数组prices的第一个元素。显示第一个元素后不断执行循环，而x依次表示数组的其他元素。<br>要修改数组的元素，需要使用不同的循环变量语法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> &amp;x : prices)</span><br><span class="line">x = x * <span class="number">0.80</span>;</span><br></pre></td></tr></table></figure></p><p>符号&amp;表明x是一个引用变量，这个将在后面学习。就这里而言，这种声明可以修改数组的内容，而第一种语法不行。<br>还可以结合使用基于范围的for循环和初始化列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>&#125;)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p><p>然而，这种循环主要用于后面的各种模板容器类。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记三</title>
      <link href="/2019/03/31/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
      <url>/2019/03/31/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>关于类vector和array的一些内容<br><a id="more"></a></p><h2 id="数组的替代品"><a href="#数组的替代品" class="headerlink" title="数组的替代品"></a>数组的替代品</h2><h3 id="模板类vector"><a href="#模板类vector" class="headerlink" title="模板类vector"></a>模板类vector</h3><p>模板类vector类似于string类，也是一种动态数组。可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的。<br>这里不深入探讨模板类意味着什么，只介绍一些基本的实用知识。首先，要使用vector对象，必须包含头文件vector。其次，vector包含在名称空间std中，因此可以使用using编译指令、using声明或std::vector。第三，模板使用不同的语法来指出它储存的数据类型。第四，vector类使用不同的语法来制定元素数。下面是一些示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;<span class="comment">// create a zero-size array of int</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd(n);<span class="comment">// create an array of n doubles</span></span><br></pre></td></tr></table></figure></p><p>其中，vi是一个vector<int>对象。由于vector对象在插入或添加时自动调整长度，因此可以将vi的初始长度设置为零。但要调整长度，需要使用vector包中的各种方法。<br>一般而言，下面的声明创建一个名为vt的vector对象，它可存储n_elem个类型为typeName的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;typeName&gt; vt(n_elem);</span><br></pre></td></tr></table></figure></int></p><p>其中参数n_elem可以是整形常量，也可以是整形变量。</p><h3 id="模板类array（C-11）"><a href="#模板类array（C-11）" class="headerlink" title="模板类array（C++11）"></a>模板类array（C++11）</h3><p>vector类的功能比数组强大，但付出的代价是效率稍低。如果需要的是长度固定的数组，使用数组时更佳的选择，但代价是不那么方便和安全。有鉴于此，C++11新增了模板类array，它也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。要创建array对象，需要包含头文件array。array对象的创建语法与vector稍有不同：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; ai;<span class="comment">// create array object of 5 ints</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; ad = &#123;<span class="number">1.2</span>, <span class="number">2.1</span>, <span class="number">3.43</span>, <span class="number">4.3</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>推而广之，下面的声明创建一个名为arr的array对象，它包含n_elem个类型为typeName的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;typeName, n_elem&gt; arr;</span><br></pre></td></tr></table></figure></p><p>与创建vector对象不同的是，n_elem不能是变量。<br>在C++11中，可将列表初始化用于vector和array对象，但在C++98中，不能对vector对象这样做。</p><h3 id="比较数组、vector对象和array对象"><a href="#比较数组、vector对象和array对象" class="headerlink" title="比较数组、vector对象和array对象"></a>比较数组、vector对象和array对象</h3><p>要了解数组、vector对象和array对象的相似和不同之处，最简单的方式可能是看一个使用它们的示例，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choice.cpp -- array variations</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;// STL C++98</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;// C++11</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// C, original C++</span></span><br><span class="line"><span class="keyword">double</span> a1[<span class="number">4</span>] = &#123;<span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">3.6</span>, <span class="number">4.8</span>&#125;;</span><br><span class="line"><span class="comment">// C++98 STL</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; a2[<span class="number">4</span>];<span class="comment">// create vector with 4 elements</span></span><br><span class="line"><span class="comment">// no simple way to initialize in C98</span></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">1.0</span>/<span class="number">3.0</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">1.0</span>/<span class="number">5.0</span>;</span><br><span class="line">a2[<span class="number">2</span>] = <span class="number">1.0</span>/<span class="number">7.0</span>;</span><br><span class="line">a2[<span class="number">3</span>] = <span class="number">1.0</span>/<span class="number">9.0</span>;</span><br><span class="line"><span class="comment">// C++11 -- create and initialize array object</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; a3 = &#123;<span class="number">3.14</span>, <span class="number">2.72</span>, <span class="number">1.62</span>, <span class="number">1.41</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; a4;</span><br><span class="line">a4 = a3;<span class="comment">// valid for array objects of same size</span></span><br><span class="line"><span class="comment">// use array notation</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a1[2]: "</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a1[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a2[2]: "</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a2[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a3[2]: "</span> &lt;&lt; a3[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a3[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a4[2]: "</span> &lt;&lt; a4[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a4[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// misdeed</span></span><br><span class="line">a1[<span class="number">-2</span>] = <span class="number">20.2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a1[-2]: "</span> &lt;&lt; a1[<span class="number">-2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a1[<span class="number">-2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a3[2]: "</span> &lt;&lt; a3[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a3[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a4[2]: "</span> &lt;&lt; a4[<span class="number">2</span>] &lt;&lt; <span class="string">" at "</span>&lt;&lt; &amp;a4[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是该程序的输出示例：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a1</span><span class="selector-attr">[2]</span>: 3<span class="selector-class">.6</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28cce8</span></span><br><span class="line"><span class="selector-tag">a2</span><span class="selector-attr">[2]</span>: 0<span class="selector-class">.142857</span> <span class="selector-tag">at</span> 0<span class="selector-tag">xca0328</span></span><br><span class="line"><span class="selector-tag">a3</span><span class="selector-attr">[2]</span>: 1<span class="selector-class">.62</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28ccc8</span></span><br><span class="line"><span class="selector-tag">a4</span><span class="selector-attr">[2]</span>: 1<span class="selector-class">.62</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28cca8</span></span><br><span class="line"><span class="selector-tag">a1</span><span class="selector-attr">[-2]</span>: 20<span class="selector-class">.2</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28ccc8</span></span><br><span class="line"><span class="selector-tag">a3</span><span class="selector-attr">[2]</span>: 20<span class="selector-class">.2</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28ccc8</span></span><br><span class="line"><span class="selector-tag">a4</span><span class="selector-attr">[2]</span>: 1<span class="selector-class">.62</span> <span class="selector-tag">at</span> 0<span class="selector-tag">x28cca8</span></span><br></pre></td></tr></table></figure></p><h4 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h4><p>首先，注意到不论是数组、vector对象还是array对象，都可使用标准数组表示法来访问各个元素。其次，从地址可知，array对象和数组储存在相同的内存区域（即栈）中，而vector对象存储在另一个区域（自由存储区或堆中）。第三，注意到可以将一个array对象赋给另一个array对象；而对于数组，必须逐元素复制数据。<br>接下来，下面一行代码需要特别注意：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1[<span class="number">-2</span>] = <span class="number">20.2</span>;</span><br></pre></td></tr></table></figure></p><p>索引-2是什么意思呢？它将会被转换为如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(a1<span class="number">-2</span>) = <span class="number">20.2</span>;</span><br></pre></td></tr></table></figure></p><p>其含义如下：找到a1指向的地方，向前移两个double元素，并将20.2存储到目的地。也就是说，将信息存储到数组的外面。与C语言一样，C++也不检查这种超界错误。在这个示例中，这个位置位于array对象a3中。其他编辑器可能将20.2放在a4中，甚至做出更糟糕的选择。这表明数组的行为是不安全的。<br>vector和array对象能够禁止这种行为吗？答案取决于程序员自身，也就是说，仍可编写不安全的代码，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a2[<span class="number">-2</span>] = <span class="number">.5</span><span class="comment">// still allowed</span></span><br><span class="line">a3[<span class="number">200</span>] = <span class="number">1.4</span>;</span><br></pre></td></tr></table></figure></p><p>然而，也有其他的选择。一种是使用成员函数at()。就像使用cin对象的成员函数getline()一样，也可以使用vector和array对象的成员函数at()：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.at(<span class="number">1</span>) = <span class="number">2.3</span>;<span class="comment">// assign 2.3 to a2[1]</span></span><br></pre></td></tr></table></figure></p><p>中括号表示法和成员函数at()的差别在于，使用at()时，将在运行期间捕获非法索引，而程序默认将中断。这种额外检查的代价时运行时间更长，这就是C++允许使用任何一种表示法的原因所在。另外，这些类还能够降低意外超界错误的概率。例如，他们包含成员函数begin()和end()，让程序员能够确定边界，以免无意间超界，这将在后面学习。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记二</title>
      <link href="/2019/03/22/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2019/03/22/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>关于复合类型的一些内容<br><a id="more"></a></p><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>和C语言类似，C++中也可以创建数组。数组声明应指出以下3点：<br>·储存在每个元素中的值的类型;<br>·数组名;<br>·数组中的元素数;<br>和C语言类似，声明数组的通用格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeName arrayName[arraySize];</span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="keyword">short</span> months[<span class="number">12</span>];</span><br></pre></td></tr></table></figure></p><p>和C语言一致，数组从0开始编号。例如，months[0]是months数组的第一个元素。可以通过索引来标示和访问各个元素。</p><h4 id="有效下标值"><a href="#有效下标值" class="headerlink" title="有效下标值"></a>有效下标值</h4><p>编译器不会检查使用的下标是否有效。在程序运行后，可能会引发问题。所以必须确保程序只使用有效的下标值。</p><h4 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h4><p>只有定义数组时才能使用初始化，此后就不能使用了，也不能进行数组间的赋值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cards[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;<span class="comment">// okay</span></span><br><span class="line"><span class="keyword">int</span> hand[<span class="number">4</span>];<span class="comment">// okay</span></span><br><span class="line">hand[<span class="number">4</span>] = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;<span class="comment">// not allowed</span></span><br><span class="line">hand = cards;<span class="comment">// not allowed</span></span><br></pre></td></tr></table></figure></p><p>如果初始化时方括号内为空，则编译器将计算元素个数。</p><h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><p>ISO/ANSI C++98标准通过添加string类扩展C++库，因此现在可以用string类型的变量(C++称之为对象)而非字符数组来存储字符串。这使用起来比数组简单。<br>要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此也需要使用using编译指令，或是std::string来引用。string类定义隐藏了字符串数组性质，因此可以像处理普通变量一样处理字符串。</p><h4 id="赋值、拼接、附加"><a href="#赋值、拼接、附加" class="headerlink" title="赋值、拼接、附加"></a>赋值、拼接、附加</h4><p>参看如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> charr1[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> charr2[<span class="number">20</span>] = <span class="string">"jaguar"</span>;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"panther"</span>;</span><br><span class="line">charr1 = charr2;<span class="comment">// INVALID</span></span><br><span class="line">str1 = str2;<span class="comment">// VALID</span></span><br></pre></td></tr></table></figure></p><p>string类简化了字符串的合并操作。在C语言中使用strcat(str1,str2)函数来进行拼接，且有诸多注意事项，但是string类则可以使用运算符+将两个string对象合并起来，也可以使用运算符+=将字符串附加到string对象的末尾。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str3;</span><br><span class="line">str3 = str1 + str2;<span class="comment">// assign str3 to the joined strings</span></span><br><span class="line">str1 += str2;<span class="comment">// add str2 to the end of str1</span></span><br></pre></td></tr></table></figure></p><p>当然，C++中也可以使用C语言库中的函数来完成这些任务。头文件cstring(以前为string.h)中提供了这些函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(charr1, charr2);<span class="comment">// copy charr2 to charr1</span></span><br><span class="line"><span class="built_in">strcat</span>(charr1, charr2);<span class="comment">// append contents of charr2 to charr1</span></span><br></pre></td></tr></table></figure></p><p>当然，在VS2017的编译环境中，会采用更安全的strcpy_s，strcat_s函数。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>和C语言相同，C++也提供结构体，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span>// <span class="title">structure</span> <span class="title">declaration</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">float</span> volume;</span><br><span class="line"><span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外，还有共用体(union，有时也叫做联合)、枚举(enum)等结构，在此便不赘述。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>熟悉C语言的都对指针有一定了解，我们在此便略过基础的知识。  </p><h4 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h4><p>C语言中我们使用malloc()来分配内存，而在C++中，可以使用new运算符来进行。<br>下面来试试这种新技术，在运行阶段将一个int值分配未命名内存，并使用指针来进行访问。程序员需要告诉new，需要为哪种数据类型分配内存;new将找到一个正确的内存块，并返回该内存块的地址。程序员的责任是将其赋给一个指针，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pn = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure></p><p>new int告诉程序，需要适合储存int的内存。new运算符根据类型来确定需要多少字节的内存，它找到这样的内存并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针。现在，pn是地址，而*pn是春促在那里的值。将其与将变量的地址赋给指针进行比较：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> higgens;</span><br><span class="line"><span class="keyword">int</span> * pt = &amp;higgens;</span><br></pre></td></tr></table></figure></p><p>在这两种情况下，都是将一个int变量地址赋给了指针。在第二种情况下，可以用名称higgens来访问该int，在第一种情况下，只能通过该指针进行访问。这便引出了一个问题：pn指向的内存没有名称，如何称呼它呢？我们说pn指向一个数据对象(不是“面向对象编程”的对象，而是一样东西)，术语“数据对象”比“变量”更为通用，它指的是为数据项分配的内存块。因此，变量也是数据对象，而pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。<br>为一个数据对象(可以是结构，也可以是基本类型)获得并制定分配内存的通用格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointer_name = <span class="keyword">new</span> typeName;</span><br></pre></td></tr></table></figure></p><p>需要在两个地方制定数据类型。</p><h4 id="使用delete来释放内存"><a href="#使用delete来释放内存" class="headerlink" title="使用delete来释放内存"></a>使用delete来释放内存</h4><p>在C语言中，一定会提到的便是malloc()之后，一定要有一个free()。这是为了避免程序将内存耗尽。C++中，使用delete运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">// allocate memory with new</span></span><br><span class="line">...<span class="comment">// use the memory</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// free memory with delete when done</span></span><br></pre></td></tr></table></figure></p><p><strong>警告：只能使用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的</strong><br><strong>不要尝试释放已经释放的内存块，这样做的结果将会是不确定的。另外，不能使用delete来释放声明变量所获得的内存</strong><br>值得注意的是，使用delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">// allocate memory</span></span><br><span class="line"><span class="keyword">int</span> * pq = ps;<span class="comment">// set second pointer to same block</span></span><br><span class="line"><span class="keyword">delete</span> pq;<span class="comment">// delete with second pointer</span></span><br></pre></td></tr></table></figure></p><p>一般来说，不要创建两个指向同一个内存块的指针。因为这将增加错误删除同一个内存块两次的可能性。不过，在之后的学习中，将会学习到，对于返回指针的函数，使用另一个指针确实有道理。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer Plus 学习笔记一</title>
      <link href="/2019/03/21/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2019/03/21/C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>从零开始接触C++<br><a id="more"></a><br>在经历了种种困难(其实并没有太多)之后，我开了这篇博客，在此记录我从头开始学习C++的历程。参考教材：《C++ Primer Plus (第六版) 中文版》<br>目录按照教材的目录记录  </p><h2 id="第1章-预备知识"><a href="#第1章-预备知识" class="headerlink" title="第1章 预备知识"></a>第1章 预备知识</h2><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>·C语言和C++的发展历史和基本原理。<br>·过程性编程和面向对象编程。<br>·C++是如何在C语言的基础上添加面向对象概念的。<br>·C++是如何在C语言的基础上添加泛型编程概念的。<br>·编程语言标准。<br>·创建程序的技巧。<br>本章内容请在书上阅读，这里不再赘述，以下是大纲。</p><h4 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h4><h4 id="C-简史"><a href="#C-简史" class="headerlink" title="C++简史"></a>C++简史</h4><p>1.2.1 C语言<br>1.2.2 C语言编程原理<br>1.2.3 面向对象编程<br>1.2.4 C++和泛型编程<br>1.2.5 C++的起源  </p><h4 id="可移植性和标准"><a href="#可移植性和标准" class="headerlink" title="可移植性和标准"></a>可移植性和标准</h4><p>1.3.1 C++的发展<br>1.3.2 本书遵循的C++标准</p><h4 id="程序创建的技巧"><a href="#程序创建的技巧" class="headerlink" title="程序创建的技巧"></a>程序创建的技巧</h4><p>1.4.1 创建源代码文件<br>1.4.2 编译和链接  </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h2 id="第2章-开始学习C"><a href="#第2章-开始学习C" class="headerlink" title="第2章 开始学习C++"></a>第2章 开始学习C++</h2><h3 id="大纲-1"><a href="#大纲-1" class="headerlink" title="大纲"></a>大纲</h3><p>·创建C++程序。<br>·C++程序的一般格式。<br>·#include编译指令。<br>·main()函数。<br>·使用cout对象进行输出。<br>·在C++程序中加入注释。<br>·何时以及如何使用endl。<br>·声明和使用变量。<br>·使用cin对象进行输入。<br>·定义和使用简单函数。  </p><h3 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h3><p>下面是教材中的一个cpp程序的源代码，我们从这个程序开始逐步理清楚。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myfirst.cpp -- displays a message  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;// a PREPROCESSOR directive</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">// function header</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// start of function body</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">// make definitions visible</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Come up and C++ me some time."</span>;<span class="comment">// message</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// start a new line</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"You won't regret it!"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// more output</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// terminate main()</span></span><br><span class="line">&#125;<span class="comment">// end of function body</span></span><br></pre></td></tr></table></figure></p><p>从某种意义上来讲，C++和C语言有很大的相似之处，因此我们直接将略过和C语言相似的部分。  </p><h4 id="头文件名"><a href="#头文件名" class="headerlink" title="头文件名"></a>头文件名</h4><p>第一行代码是#include <iostream> ，和C语言类似，像iostream这样的文件叫做包含文件(include file)——由于被包含在其他的文件中，也称作头文件(header file)。C语言的头文件一般使用h扩展名，但C++却没有扩展名。有些C头文件被转换为C++头文件，这些文件在文件名称上加上前缀c，例如C++版本的math.h则是cmath。对于纯粹的C++头文件来讲，去掉h后的头文件还可以包含名称空间。</iostream></p><h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h4><p>注意到和C语言不同的是那一句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure></p><p>这叫做using编译指令，在后面会进行深度的学习，现在仅仅只作了解。<br>名称空间支持是一项C++特性，旨在编写大型程序时以及将多个厂商现有代码组合起来更加容易，它也有助于组织程序。一个潜在的问题是，如果使用两个封装好产品，而它们都有一个叫做tietie()的函数，那么编译器将不知道是使用哪一个tietie()。名称空间使得厂商可以将其产品封装在一个叫做名称空间的单元中，这样便能用其来指出想要使用哪个厂商的产品。因此，Meaqua Industries可以将其定义放到一个叫做Meaqua的名称空间中。如此一来，其tietie()函数的全程就是Meaqua::tietie();同样，HimeHina公司的tietie()版本可以表示为HimeHina::tietie()。这样，程序就能使用名称空间来区分不同的版本了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Meaqua::tietie(<span class="string">"Meaquaraft"</span>);<span class="comment">// use Meaqua namespace version</span></span><br><span class="line">HimeHina::tietie(<span class="string">"Yuki"</span>);<span class="comment">// use HimeHina namespace version</span></span><br></pre></td></tr></table></figure></p><p>因此来讲，上面的iostream定义的输出的cout变量其实是std::cout，endl实际上是std::endl。因此也可以省略using，以下述方式编码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Come up and C++ me some time."</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>然而，多数用户并不喜欢将引入名称空间之前的代码(使用iostream.h和cout)转换为名称空间代码(使用iostream和std::cout)，除非他们可以毫不费力地完成这种转换。于是，using指令便应运而生了。下面的代码表示可以使用std名称空间定义的名称，而不必使用std::前缀：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure></p><p>这个using编译指令使得std名称空间中的所有名称均可用。这是一种偷懒的做法，在大型项目中会有潜在的问题。更好的方法是，只使得需要的名称可用，这也可以通过using实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;<span class="comment">// make cout available</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// make endl available</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;<span class="comment">// make cin available</span></span><br><span class="line"><span class="keyword">using</span> Meaqua::tietie;<span class="comment">// make tietie available</span></span><br></pre></td></tr></table></figure></p><h4 id="关于cout"><a href="#关于cout" class="headerlink" title="关于cout"></a>关于cout</h4><p>注意到myfirst.cpp中的以下语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Come up and C++ me some time."</span>;</span><br></pre></td></tr></table></figure></p><p>双引号中是要打印的消息。C++中将其称作字符串。&lt;&lt;符号表示将这个字符串发送给cout;该符号指出了信息流动的路径。那么什么是cout？它是一个预定义的对象，知道如何显示字符串、数字和单个字符等。<br>cout有一个简单的接口，如果string是一个字符串，则下面的代码将显示该字符串：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure></p><p>和C语言中的printf()有些不同，与其将cout显示了一条字符串，倒不如说是将字符串插入到输出流(从C++概念上来看，输出是一个流，即从程序流出的一系列字符)中。cout对象表示这种流，其属性在iostream中定义。cout的对象属性中包含有一个插入运算符(&lt;&lt;)，它可以将右侧信息插入到流中。  </p><h5 id="初识运算符重载"><a href="#初识运算符重载" class="headerlink" title="初识运算符重载"></a>初识运算符重载</h5><p>注意到插入运算符和按位左移运算符(在C语言中进行位运算时执行向左移位操作的符号)似乎是有极大的相似性，这是一个运算符重载的例子，通过重载，同一个运算符将有不同的含义。编译器通过上下文来确定运算符的含义。在C语言中，也有这种例子，例如&amp;符号，既可以表示地址运算符，也可以表示按位与运算符。*即表示乘法，也表示指针的解引用。C++扩展了运算符重载的概念，允许用户定义的类型(类)重新定义运算符的含义。</p><h5 id="cout和printf"><a href="#cout和printf" class="headerlink" title="cout和printf()"></a>cout和printf()</h5><p>和printf()相比，cout设计更加灵活、好用，并且它是可扩展的(extensible)。也就是说，可以重新定义&lt;&lt;运算符，使得cout可以识别并显示开发的新数据类型。若是喜欢printf()提供的细致控制功能，可以使用更高级的cout来获得相同效果，这将在之后的学习中提到。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2019/03/21/Hello-Hexo/"/>
      <url>/2019/03/21/Hello-Hexo/</url>
      
        <content type="html"><![CDATA[<p>使用Hexo,是一件非常简单的事。测试文本</p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/21/hello-world/"/>
      <url>/2019/03/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
